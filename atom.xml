<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://alang.two3.cn</id>
    <title>Jump!Alang</title>
    <updated>2019-11-04T08:18:13.409Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://alang.two3.cn"/>
    <link rel="self" href="http://alang.two3.cn/atom.xml"/>
    <subtitle>永远年轻！永远热泪盈眶！</subtitle>
    <logo>http://alang.two3.cn/images/avatar.png</logo>
    <icon>http://alang.two3.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, Jump!Alang</rights>
    <entry>
        <title type="html"><![CDATA[thingsboard网关扩展与tb同步的理解]]></title>
        <id>http://alang.two3.cn/post/thingsboard-wang-guan-kuo-zhan-yu-tb-tong-bu-de-li-jie</id>
        <link href="http://alang.two3.cn/post/thingsboard-wang-guan-kuo-zhan-yu-tb-tong-bu-de-li-jie">
        </link>
        <updated>2019-11-04T07:20:31.000Z</updated>
        <summary type="html"><![CDATA[<p>最近由于要经常操作网关扩展，如添加http扩展，新增mqtt扩展的映射。经常出现网关不同步问题。导致了经过网关的数据，设备有创建，但是没有相应遥测数据，之前有看过群里大佬写过thingsboard网关与tb配置同步的源码分析：</p>
<blockquote>
<p><a href="https://blog.csdn.net/Zzhou1990/article/details/102477059">https://blog.csdn.net/Zzhou1990/article/details/102477059</a> <em><strong>Thingsboard Gateway 根据云端配置初始化</strong></em></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<p>最近由于要经常操作网关扩展，如添加http扩展，新增mqtt扩展的映射。经常出现网关不同步问题。导致了经过网关的数据，设备有创建，但是没有相应遥测数据，之前有看过群里大佬写过thingsboard网关与tb配置同步的源码分析：</p>
<blockquote>
<p><a href="https://blog.csdn.net/Zzhou1990/article/details/102477059">https://blog.csdn.net/Zzhou1990/article/details/102477059</a> <em><strong>Thingsboard Gateway 根据云端配置初始化</strong></em></p>
</blockquote>
<!-- more -->
<h1 id="前记">前记</h1>
<p>以上纯属本人臆想推测，欢迎看者多加指正，互相进步。</p>
<h1 id="理解大佬源码分析">理解大佬源码分析</h1>
<p>从大佬文章中，大致可以理解成:当网关配置与thingsboard互通后，并允许thingsboard远程更新，则网关中连接thingsboard mqtt broker的mqtt客户端有订阅了属性更新主题<code>v1/devices/me/attributes</code>，用于实时获取共享属性更新。每当在thingsboard平台上配置网关扩展，thingsboard就会自动将配置信息保存为共享属性<code>configuration</code>的值。此时网关中的mqtt客户端监听到共享属性更新，会根据共享属性值重新初始化网关扩展配置。而后再把相应扩展配置上传至网关客户端属性<code>appliedConfiguration</code>,见如下代码：</p>
<pre><code class="language-java">private void updateConfiguration(String configuration) {
        try {
            if (extensionsConfigListener != null) {
                extensionsConfigListener.accept(configuration);
            }
            onAppliedConfiguration(configuration);
        } catch (Exception e) {
            log.warn(&quot;Failed to update extension configurations [[]]&quot;, e.getMessage(), e);
        }

public void onAppliedConfiguration(String configuration) {
        byte[] msgData = toBytes(newNode().put(&quot;appliedConfiguration&quot;, configuration));
        persistMessage(DEVICE_ATTRIBUTES_TOPIC, msgIdSeq.incrementAndGet(), msgData, null, null,
                error -&gt;
                        log.warn(&quot;Could not publish applied configuration&quot;, error));
    }
</code></pre>
<h1 id="同步状态判断依据">同步状态判断依据</h1>
<p>查阅thingsboard ui模块下的如下文件：<br>
<code>D:\JAVA\iot\code\thingsboard\ui\src\app\extension\extension-table.directive.js</code><br>
确认同步方法：</p>
<pre><code class="language-js">function reloadExtensions() {
        vm.subscribed = false;
        vm.allExtensions.length = 0;
        vm.extensions.length = 0;
        vm.extensionsPromise = attributeService.getEntityAttributesValues(vm.entityType, vm.entityId, types.attributesScope.shared.value, [&quot;configuration&quot;]);
        vm.extensionsPromise.then(
            function success(data) {
                if (data.length) {
                    vm.allExtensions = angular.fromJson(data[0].value);
                } else {
                    vm.allExtensions = [];
                }

                vm.selectedExtensions = [];
                updateExtensions();
                vm.extensionsPromise = null;
            },
            function fail() {
                vm.extensions = [];
                vm.selectedExtensions = [];
                updateExtensions();
                vm.extensionsPromise = null;
            }
        );
    }

function updateExtensions() {
        vm.selectedExtensions = [];
        var result = $filter('orderBy')(vm.allExtensions, vm.query.order);
        // $log.info(result);
        if (vm.query.search != null) {
            result = $filter('filter')(result, function(extension) {
                if(!vm.query.search || (extension.id.indexOf(vm.query.search) != -1) || (extension.type.indexOf(vm.query.search) != -1)) {
                    return true;
                }
                return false;
            });
        }
        vm.extensionsCount = result.length;
        var startIndex = vm.query.limit * (vm.query.page - 1);
        vm.extensions = result.slice(startIndex, startIndex + vm.query.limit);

        vm.extensionsJSON = angular.toJson(vm.extensions);
        checkForSync();
    }

function subscribeForClientAttributes() {
        if (!vm.subscribed) {
            if (vm.entityId &amp;&amp; vm.entityType) {
                $scope.subscriber = {
                    subscriptionCommands: [{
                        entityType: vm.entityType,
                        entityId: vm.entityId,
                        scope: 'CLIENT_SCOPE'
                    }],
                    type: 'attribute',
                    onData: function (data) {
                        if (data.data) {
                            onSubscriptionData(data.data);
                        }
                        vm.subscribed = true;
                    }
                };
                telemetryWebsocketService.subscribe($scope.subscriber);
            }
        }
    }

function onSubscriptionData(data) {
         // $log.info(data);
        if ($.isEmptyObject(data)) {
            vm.appliedConfiguration = undefined;
        } else {
            if (data.appliedConfiguration &amp;&amp; data.appliedConfiguration[0] &amp;&amp; data.appliedConfiguration[0][1]) {
                vm.appliedConfiguration = data.appliedConfiguration[0][1];
            }
        }

        updateExtensions();
        $scope.$digest();
    }

function checkForSync() {
         // $log.info(&quot;app:&quot;+vm.appliedConfiguration);
         // $log.info(&quot;ext:&quot;+vm.extensionsJSON);
        if (vm.appliedConfiguration &amp;&amp; vm.extensionsJSON &amp;&amp; vm.appliedConfiguration === vm.extensionsJSON) {
            vm.syncStatus = $translate.instant('extension.sync.sync');
            vm.syncLastTime = formatDate();
            $scope.isSync = true;
        } else {
            vm.syncStatus = $translate.instant('extension.sync.not-sync');

            $scope.isSync = false;
        }
    }
</code></pre>
<p>可以看出同步状态是通过判断网关的客户端属性<code>appliedConfiguration</code>与加工过的共享属性<code>configuration</code>值是否一致。<br>
同时发现一个自认为的bug：共享属性<code>configuration</code>会被排序加工成<code>extensionsJSON</code>,排序是根据扩展id升序排序的,所以会导致客户端属性与加工后的共享属性不一致，导致提示不同步，但好像并不影响使用：<br>
<code>var result = $filter('orderBy')(vm.allExtensions, vm.query.order);</code></p>
<pre><code class="language-js">vm.query = {
        order: 'id',
        limit: 5,
        page: 1,
        search: null
    };
</code></pre>
<p>所以我自己建议是添加网关扩展时id累加命名，如1_green,2_red。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[thingsboard gateway http扩展 创建设备、上传属性及遥测数据]]></title>
        <id>http://alang.two3.cn/post/thingsboard-gateway-http-kuo-zhan-shang-chuan-shu-xing-ji-yao-ce-shu-ju</id>
        <link href="http://alang.two3.cn/post/thingsboard-gateway-http-kuo-zhan-shang-chuan-shu-xing-ji-yao-ce-shu-ju">
        </link>
        <updated>2019-11-01T08:02:53.000Z</updated>
        <summary type="html"><![CDATA[<p>thingsboard官网文档有介绍网关mqtt扩展的使用，http扩展的使用方法找了许久也未找到。于是就想从thinsboard pe版本中的http整合找下灵感。pe版本中的http整合其实也就是提供中间的一个整合器服务和转换器（可以转换json/text/binary(base64)），然后跟着这个线索去查看gateway的源码，发现有一个controller有配置uplink上传链，至于downlink还待研究。<em><strong>对于thingsboard还是小白，如文章理解有误，希望看者多多帮忙指正，互相一起进步</strong></em></p>
]]></summary>
        <content type="html"><![CDATA[<p>thingsboard官网文档有介绍网关mqtt扩展的使用，http扩展的使用方法找了许久也未找到。于是就想从thinsboard pe版本中的http整合找下灵感。pe版本中的http整合其实也就是提供中间的一个整合器服务和转换器（可以转换json/text/binary(base64)），然后跟着这个线索去查看gateway的源码，发现有一个controller有配置uplink上传链，至于downlink还待研究。<em><strong>对于thingsboard还是小白，如文章理解有误，希望看者多多帮忙指正，互相一起进步</strong></em></p>
<!-- more -->
<h1 id="gateway源码查看">gateway源码查看</h1>
<p>在<code>httpController</code>有如下方法：</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/uplink/{converterId}&quot;, method = RequestMethod.POST)
    public void handleRequest(@PathVariable String converterId,
                              @RequestBody String body) throws Exception {
        service.processRequest(converterId, null, body);
    }
</code></pre>
<h1 id="gateway扩展配置">gateway扩展配置</h1>
<p>至thingsboard平台配置网关设备的扩展，新增http扩展。如下：<br>
<img src="http://alang.two3.cn/post-images/1572596736680.png" alt=""><br>
<img src="http://alang.two3.cn/post-images/1572596746058.png" alt=""><br>
<img src="http://alang.two3.cn/post-images/1572596750984.png" alt=""><br>
<img src="http://alang.two3.cn/post-images/1572596757416.png" alt=""></p>
<h1 id="postman调用http扩展url">postman调用http扩展url</h1>
<p>上一步骤我们配置了转换器序列号为green,网关默认开启端口号为9090，则http请求地址为：网关地址ip:9090/uplink/green。<br>
<img src="http://alang.two3.cn/post-images/1572599651241.png" alt=""></p>
<h1 id="至tb平台上查看设备及数据">至tb平台上查看设备及数据</h1>
<figure data-type="image" tabindex="1"><img src="http://alang.two3.cn/post-images/1572599728628.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[postgresql-11.5.1安装timescaledb-1.4.2后无法加载库解决方法]]></title>
        <id>http://alang.two3.cn/post/postgresql-1151-an-zhuang-timescaledb-142-hou-wu-fa-jia-zai-ku-jie-jue-fang-fa</id>
        <link href="http://alang.two3.cn/post/postgresql-1151-an-zhuang-timescaledb-142-hou-wu-fa-jia-zai-ku-jie-jue-fang-fa">
        </link>
        <updated>2019-10-19T17:08:27.000Z</updated>
        <summary type="html"><![CDATA[<p>之前为了尝鲜了，装了最新版的postgresql数据库，而后安装完时序数据库timescaledb报了如下错误<code>无法加载库 &quot;d:/program files/postgresql/11/lib/timescaledb-1.4.2.dll&quot;</code>，解决这个问题还是花费了不少时间，写在这希望能帮助遇到同样问题的人。</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前为了尝鲜了，装了最新版的postgresql数据库，而后安装完时序数据库timescaledb报了如下错误<code>无法加载库 &quot;d:/program files/postgresql/11/lib/timescaledb-1.4.2.dll&quot;</code>，解决这个问题还是花费了不少时间，写在这希望能帮助遇到同样问题的人。</p>
<!-- more -->
<h1 id="查找原因">查找原因</h1>
<p>在各种google后，终于在timescaledb的github的issues看到有网友碰到同样的问题。<br>
<a href="https://github.com/timescale/timescaledb/issues/1398">https://github.com/timescale/timescaledb/issues/1398</a><br>
在其中找到了答案：</p>
<blockquote>
<p>You would need libeay32.dll and ssleay32.dll from the bin folder of the 11.4 installation.<br>
Zip file downloadable from here: https://get.enterprisedb.com/postgresql/postgresql-11.4-1-windows-x64-binaries.zip<br>
应该算官方的一个bug:最新版postgredql-11.5.1缺少两个dll, <strong>libeay32.dll</strong> 和 <strong>ssleay32.dll</strong>。</p>
</blockquote>
<h1 id="解决方案">解决方案</h1>
<p>至如下网址下载postgresql-11.4的安装包，然后找到bin下的这两个dll，复制到你安装的postgresql/bin目录下<br>
<a href="https://get.enterprisedb.com/postgresql/postgresql-11.4-1-windows-x64-binaries.zip">https://get.enterprisedb.com/postgresql/postgresql-11.4-1-windows-x64-binaries.zip</a><br>
或者至百度网盘下载我提取出来的dll：<br>
链接: <a href="https://pan.baidu.com/s/1ZTRL3ukfABm6rmzyy_-42Q&amp;shfl=shareset">https://pan.baidu.com/s/1ZTRL3ukfABm6rmzyy_-42Q&amp;shfl=shareset</a> 提取码: jdzb</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ThingsBoard修改logo]]></title>
        <id>http://alang.two3.cn/post/thingsboard-xiu-gai-logo-ji-biao-ti</id>
        <link href="http://alang.two3.cn/post/thingsboard-xiu-gai-logo-ji-biao-ti">
        </link>
        <updated>2019-10-16T16:35:26.000Z</updated>
        <summary type="html"><![CDATA[<p>本来以为很简单的事，但其中问题不断，写在此愿能帮助遇到同样问题的你。<br>
要实时查看logo替换效果，建议在热部署模式下运行，官方文档：<a href="https://thingsboard.io/docs/user-guide/contribution/how-to-contribute/#running-ui-container-in-hot-redeploy-mode">https://thingsboard.io/docs/user-guide/contribution/how-to-contribute/#running-ui-container-in-hot-redeploy-mode</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>本来以为很简单的事，但其中问题不断，写在此愿能帮助遇到同样问题的你。<br>
要实时查看logo替换效果，建议在热部署模式下运行，官方文档：<a href="https://thingsboard.io/docs/user-guide/contribution/how-to-contribute/#running-ui-container-in-hot-redeploy-mode">https://thingsboard.io/docs/user-guide/contribution/how-to-contribute/#running-ui-container-in-hot-redeploy-mode</a></p>
<!-- more -->
<h1 id="定制自己的logo">定制自己的logo</h1>
<p>我这边使用的是在线网页制作svg：<a href="https://c.runoob.com/more/svgeditor/">https://c.runoob.com/more/svgeditor/</a></p>
<ol>
<li>准备工作<br>
把thingsboard原logo(存在此路径下：<code>/UI/src/svg/log_tilte_white.svg</code>)导入在线制作svg网页</li>
<li>制作<br>
导入成功后按delete把导入的thingsboard logo背景删除（主要是为了保证图片尺寸跟原thingsboard大致一致）</li>
</ol>
<h1 id="编辑制作好的svg代码">编辑制作好的svg代码</h1>
<p>把thingsboard源logo的头部复制到你制作好的svg头部（个人理解主要是为了保证宽度高度的一致）</p>
<p>thingsboard源logo头部</p>
<pre><code class="language-html">&lt;svg id=&quot;svg2&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; height=&quot;320&quot; width=&quot;1543.4&quot; version=&quot;1.1&quot; xmlns:cc=&quot;http://creativecommons.org/ns#&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; viewBox=&quot;0 0 1543.4268 320.00026&quot;&gt;
</code></pre>
<h1 id="编译">编译</h1>
<p>把图片拷贝到thingsboard原位置，重新编译打包(要先把thingsboard根路径下的pom.xml中的license-maven-plugin插件注释了)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[thingsboard rpc大佬总结]]></title>
        <id>http://alang.two3.cn/post/thingsboard-rpc-da-lao-zong-jie</id>
        <link href="http://alang.two3.cn/post/thingsboard-rpc-da-lao-zong-jie">
        </link>
        <updated>2019-09-27T07:42:54.000Z</updated>
        <summary type="html"><![CDATA[<p>感谢大佬：@苏州-大侠，@杭州～三升水<br>
QQ群：China Thingsboard（726442610）</p>
]]></summary>
        <content type="html"><![CDATA[<p>感谢大佬：@苏州-大侠，@杭州～三升水<br>
QQ群：China Thingsboard（726442610）</p>
<!-- more -->
<h1 id="苏州-大侠">苏州-大侠</h1>
<p>1.正常 我们都是通过 mqtt，modbus，opc UA向TB抛数据<br>
2.如果想要通过TB下发指令或下发数据，就是通过tb的rpc<br>
3.tb有rpc的专属topic，对不同的协议(modbus ,mqtt,opc ua)有不同的格式<br>
4.tb下发rpc可以通过规则链，部件或调API<br>
5.如用gateway的modbus采集地址位的数据，如果想要修改地址位的数据，这时就用rpc下发数据，gateway接受到rpc的数据，就会写入地址中</p>
<h1 id="杭州~三升水">杭州～三升水</h1>
<p>1.首先我们理解RPC是什么意思，RPC和框架中的远程服务调用是一样的<br>
2.因为TB他不是单机的，就是有多个服务在一起部署的，多个机器是通过Akka模型进行通讯的<br>
3.他用grpc来进行服务的调用和消息在多个实例上传递<br>
4.这2个分别是用集群获取消息和发送消息，无论数据采集还有其他<br>
<img src="http://alang.two3.cn/post-images/1569571494278.jpg" alt=""><br>
<img src="http://alang.two3.cn/post-images/1569571500277.jpg" alt=""><br>
5.TB把单机版和集群的API做了个区分<br>
6.所以你会看到2套API,总结就是，你不是集群部署的话，rpc那套用处不大，上面采集的接口（<code>就是mqtt,coap,http的通过主题发送消息</code>）也能满足你的要求<br>
7.像这种，就是那种多个集群在一起通信的，交互消息的终端打印信息<br>
<img src="http://alang.two3.cn/post-images/1569571672429.jpg" alt=""><br>
8.网关的作用主要是对于单体没有联网能力的设备，从自组网或者局域网中，到一个有联网能力的设备上，统一上传数据</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[thingsboard rest api使用准备]]></title>
        <id>http://alang.two3.cn/post/thingsboard-rest-api-shi-yong-zhun-bei</id>
        <link href="http://alang.two3.cn/post/thingsboard-rest-api-shi-yong-zhun-bei">
        </link>
        <updated>2019-09-25T00:33:17.000Z</updated>
        <summary type="html"><![CDATA[<p>服务器端核心API</p>
]]></summary>
        <content type="html"><![CDATA[<p>服务器端核心API</p>
<!-- more -->
<p>访问地址格式：http://YOUR_HOST:PORT/swagger-ui.html<br>
如官网示例为：<a href="http://demo.thingsboard.io/swagger-ui.html">http://demo.thingsboard.io/swagger-ui.html</a></p>
<p>要使用api之前，要先取得调用api的token。</p>
<h1 id="获取token">获取token</h1>
<p>post请求地址：http://THINGSBOARD_URL/api/auth/login，如官网示例则为：http://demo.thingsboard.io/api/auth/login<br>
postman调用样例，这边以我本地为例：<br>
<img src="http://alang.two3.cn/post-images/1569372720394.png" alt=""></p>
<h1 id="调用api准备">调用api准备</h1>
<p>调用api可以直接使用swagger-ui.html也可以在postman。</p>
<ul>
<li>swagger-ui调用api准备<br>
在Swagger UI右上角的“Authorize”按钮填充api_key，api_key为&quot;Bearer &quot;+token,记得Bearer后面有个空格。<br>
<img src="http://alang.two3.cn/post-images/1569373125236.png" alt=""></li>
<li>postman调用api准备<br>
要在header加上X-Authorization<br>
<img src="http://alang.two3.cn/post-images/1569373400730.png" alt=""></li>
</ul>
<h1 id="参考">参考</h1>
<p><a href="https://thingsboard.io/docs/reference/rest-api/">https://thingsboard.io/docs/reference/rest-api/</a> REST API</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[thingsboard gateWay概述]]></title>
        <id>http://alang.two3.cn/post/thingsboard-gateway-gai-shu</id>
        <link href="http://alang.two3.cn/post/thingsboard-gateway-gai-shu">
        </link>
        <updated>2019-09-24T00:46:02.000Z</updated>
        <summary type="html"><![CDATA[<p>thingsboard网关可让您将与旧式和第三方系统连接的IoT设备与ThingsBoard集成在一起。<br>
网关是ThingsBoard中的一种特殊类型的设备，能够充当连接到不同系统的外部设备和ThingsBoard之间的桥梁。网关API提供了使用单个MQTT连接在多个设备和平台之间交换数据的功能。网关还充当ThingsBoard设备，并且可以利用现有的MQTT Device API来报告统计信息，接收配置更新等等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>thingsboard网关可让您将与旧式和第三方系统连接的IoT设备与ThingsBoard集成在一起。<br>
网关是ThingsBoard中的一种特殊类型的设备，能够充当连接到不同系统的外部设备和ThingsBoard之间的桥梁。网关API提供了使用单个MQTT连接在多个设备和平台之间交换数据的功能。网关还充当ThingsBoard设备，并且可以利用现有的MQTT Device API来报告统计信息，接收配置更新等等。</p>
<!-- more -->
<h1 id="架构">架构</h1>
<p>对平台来说网关是一个设备：只不过网关的消息体和其他设备不一样，网关监听的是消息代理发送的消息。针对MQTT来说，网关只不过选择性监听了topic，构建了一个映射“map”关系。<br>
<img src="http://alang.two3.cn/post-images/1569286524998.png" alt=""></p>
<h1 id="可以解决什么问题">可以解决什么问题</h1>
<p>现实中大部分都是通过网关操作设备的，不管是MQTT还是modbus或者opc。<br>
问题一：如果你有1万台设备如何连接： 若是你有一万个设备，不可能一个一个用token去连的。<br>
网关就解决了这个问题，简单 的说，通过网关，是管理一批设备，不通过网关，是管理一个设备。</p>
<h1 id="功能">功能</h1>
<ul>
<li>MQTT扩展，用于控制，配置和收集使用现有协议连接到外部MQTT代理的IoT设备的数据。</li>
<li>OPC-UA扩展，用于从连接到OPC-UA服务器的IoT设备收集数据。</li>
<li>Sigfox扩展，用于从连接到Sigfox后端的IoT设备收集数据。</li>
<li>Modbus扩展可从通过Modbus协议连接的IoT设备收集数据。</li>
<li>在网络和硬件故障的情况下，所收集数据的持久性可确保数据传输。</li>
<li>自动重新连接到ThingsBoard集群。</li>
<li>简单但功能强大的将传入数据和消息映射为统一格式。</li>
</ul>
<h1 id="内部机制">内部机制</h1>
<p>例如，下面列出的默认映射将强制网关订阅传感器主题，并将传入的JSON消息中的serialNumber用作设备名称。类似地，模型和温度 json对象字段将映射到相应的ThingsBoard设备属性和遥测字段。</p>
<pre><code class="language-json">{
  &quot;topicFilter&quot;: &quot;sensors&quot;,
  &quot;converter&quot;: {
    &quot;type&quot;: &quot;json&quot;,
    &quot;filterExpression&quot;: &quot;&quot;,
    &quot;deviceNameJsonExpression&quot;: &quot;${$.serialNumber}&quot;,
    &quot;attributes&quot;: [
      {
        &quot;type&quot;: &quot;string&quot;,
        &quot;key&quot;: &quot;model&quot;,
        &quot;value&quot;: &quot;${$.model}&quot;
      }
    ],
    &quot;timeseries&quot;: [
      {
        &quot;type&quot;: &quot;double&quot;,
        &quot;key&quot;: &quot;temperature&quot;,
        &quot;value&quot;: &quot;${$.temperature}&quot;
      }
    ]
  }
}
</code></pre>
<h1 id="参考">参考</h1>
<p><a href="https://thingsboard.io/docs/iot-gateway/what-is-iot-gateway/">https://thingsboard.io/docs/iot-gateway/what-is-iot-gateway/</a> <em>什么是ThingsBoard IoT网关？</em><br>
<a href="https://thingsboard.io/docs/iot-gateway/getting-started/">https://thingsboard.io/docs/iot-gateway/getting-started/</a> <em>ThingsBoard IoT网关入门</em><br>
<a href="https://thingsboard.io/docs/reference/gateway-mqtt-api/">https://thingsboard.io/docs/reference/gateway-mqtt-api/</a> <em>MQTT网关API参考</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你离开了南京，从此没有人和我说话]]></title>
        <id>http://alang.two3.cn/post/ni-chi-kai-liao-nan-jing-cong-ci-mei-you-ren-he-wo-shuo-hua</id>
        <link href="http://alang.two3.cn/post/ni-chi-kai-liao-nan-jing-cong-ci-mei-you-ren-he-wo-shuo-hua">
        </link>
        <updated>2019-08-26T14:36:20.000Z</updated>
        <summary type="html"><![CDATA[<div style="text-align:center;">
	<div>
			<audio  controls="controls" autoplay="autoplay">
			<source src="http://jumpalang.two3.cn//music/%E4%BD%A0%E7%A6%BB%E5%BC%80%E4%BA%86%E5%8D%97%E4%BA%AC%20%E4%BB%8E%E6%AD%A4%E6%B2%A1%E6%9C%89%E4%BA%BA%E5%92%8C%E6%88%91%E8%AF%B4%E8%AF%9D.mp3" type="audio/mpeg" />
	</audio>
	</div>
	</div>]]></summary>
        <content type="html"><![CDATA[<div style="text-align:center;">
	<div>
			<audio  controls="controls" autoplay="autoplay">
			<source src="http://jumpalang.two3.cn//music/%E4%BD%A0%E7%A6%BB%E5%BC%80%E4%BA%86%E5%8D%97%E4%BA%AC%20%E4%BB%8E%E6%AD%A4%E6%B2%A1%E6%9C%89%E4%BA%BA%E5%92%8C%E6%88%91%E8%AF%B4%E8%AF%9D.mp3" type="audio/mpeg" />
	</audio>
	</div>
	</div>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[冒泡、选择、插入、快速排序JAVA算法]]></title>
        <id>http://alang.two3.cn/post/mou-pao-xuan-ze-cha-ru-kuai-su-pai-xu-java-suan-fa</id>
        <link href="http://alang.two3.cn/post/mou-pao-xuan-ze-cha-ru-kuai-su-pai-xu-java-suan-fa">
        </link>
        <updated>2019-08-11T10:01:44.000Z</updated>
        <summary type="html"><![CDATA[<p>熟能生巧！</p>
]]></summary>
        <content type="html"><![CDATA[<p>熟能生巧！</p>
<!-- more -->
<h1 id="冒泡-选择-插入">冒泡、选择、插入</h1>
<pre><code class="language-java">public class OrdinarySortRepeat {
    public static void main(String[] args) {
        int[] arr = getRandomInts(10);
        int[] arr2 = Arrays.copyOf(arr,10);
        int[] arr3 = Arrays.copyOf(arr,10);
        int[] arr4 = Arrays.copyOf(arr,10);
        System.out.println(&quot;origin:&quot;+Arrays.toString(arr));
        bubbleSort(arr);
        System.out.println(&quot;bubbleSort:&quot;+Arrays.toString(arr));
        selectSort(arr2);
        System.out.println(&quot;selectSort:&quot;+Arrays.toString(arr2));
        insertSort(arr3);
        System.out.println(&quot;insertSort:&quot;+Arrays.toString(arr3));
        insertSort2(arr4);
        System.out.println(&quot;insertSort2:&quot;+Arrays.toString(arr4));
    }
    public static int[] getRandomInts(int length){
        int[] numbers = new int[length];
        Random random = new Random();
        for (int i = 0; i &lt; length; i++) {
            numbers[i] = random.nextInt(9999);
        }
        return numbers;
    }

    public static void swap(int[] arr, int a, int b){
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }

    public static void bubbleSort(int[] arr){
        for(int i = 0; i &lt; arr.length-1; i++){
            boolean isNoSorted = true;
            for(int j = 0; j &lt; arr.length-i-1; j++){
                if(arr[j] &gt; arr[j+1]){
                    swap(arr,j,j+1);
                    isNoSorted = false;
                }
            }
            if(isNoSorted){
                return;
            }
        }
    }

    public static void selectSort(int[] arr){
        for(int i = 0; i &lt; arr.length-1; i++){
            for(int j = i+1; j &lt; arr.length;j++){
                if(arr[i] &gt; arr[j]){
                    swap(arr,i,j);
                }
            }
        }
    }

    public static void insertSort(int[] arr){
        for(int i = 1; i &lt; arr.length; i++){
            int temp = arr[i];
            int j = i-1;
            while(j &gt;= 0 &amp;&amp; arr[j] &gt; temp){
                arr[j+1] = arr[j];
                j--;
            }
            arr[j+1] = temp;
        }
    }

    public static void insertSort2(int[] arr){
        for(int i = 1;i &lt; arr.length; i++){
            int temp = arr[i];
            int j;
            for(j = i-1; j &gt;= 0; j--){
                if(arr[j] &gt; temp){
                    arr[j+1] = arr[j];
                }else{
                    break;
                }
            }
            arr[j+1] = temp;
        }
    }
}

</code></pre>
<h1 id="快速排序">快速排序</h1>
<pre><code class="language-java">public class QuickSortRepeat {
    public static void main(String[] args) {
        int[] arr = getRandomInts(10);
        int[] arr2 = Arrays.copyOf(arr,10);
        int[] arr3 = Arrays.copyOf(arr,10);
        int[] arr4 = Arrays.copyOf(arr,10);
        System.out.println(&quot;origin:&quot;+Arrays.toString(arr));
        quickSort(arr,0,arr.length-1);
        System.out.println(&quot;quickSort:&quot;+Arrays.toString(arr));
        quickSort2(arr2,0,arr.length-1);
        System.out.println(&quot;quickSort2:&quot;+ Arrays.toString(arr2));
        quickSort3(arr3,0,arr.length-1);
        System.out.println(&quot;quickSort3:&quot;+Arrays.toString(arr3));
        quickSort4(arr4,0,arr.length-1);
        System.out.println(&quot;quickSort4:&quot;+Arrays.toString(arr4));
    }
    public static int[] getRandomInts(int length){
        int[] numbers = new int[length];
        Random random = new Random();
        for (int i = 0; i &lt; length; i++) {
            numbers[i] = random.nextInt(9999);
        }
        return numbers;
    }

    public static void swap(int[] arr, int a, int b){
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }

    /**
     * 根据阮一峰博客：http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html
     * @param arr
     * @param left
     * @param right
     */
    public static void quickSort(int[] arr, int left, int right){
        if(left &gt;= right){
            return;
        }
        int standard = arr[left];
        int index = left;
        for(int i = left+1; i &lt;= right; i++){
            if(arr[i] &lt; standard){
                arr[index] = arr[i];
                for(int j = i-1; j &gt; index;j--){
                    arr[j+1] = arr[j];
                }
                arr[++index] = standard;
            }
        }
        quickSort(arr,left,index-1);
        quickSort(arr,index+1,right);
    }

    /**
     * 根据马桶上看算法：http://developer.51cto.com/art/201403/430986.htm
     * @param arr
     * @param left
     * @param right
     */
    public static void quickSort2(int[] arr,int left, int right){
        if(left &gt;= right){
            return;
        }
        int standard = arr[left];
        int i = left;
        int j = right;
        while(i &lt; j){
            while(i &lt; j &amp;&amp; arr[j] &gt;= standard){
                j--;
            }
            while(i &lt; j &amp;&amp; arr[i] &lt;= standard){
                i++;
            }
            if(i &lt; j){
                swap(arr,i,j);
            }else{
                break;
            }
        }
        if(i != left){
            arr[left] = arr[i];
            arr[i] = standard;
        }

        quickSort2(arr,left,i-1);
        quickSort2(arr,i+1,right);
    }

    /**
     * 根据博客园：https://www.cnblogs.com/coderising/p/5708801.html
     * @param arr
     * @param left
     * @param right
     */
    public static void quickSort3(int[] arr, int left, int right){
        if(left &gt;= right){
            return;
        }
        int standard = arr[left];
        int i = left;
        int j = right;
        while(i &lt; j){
            while(i &lt; j &amp;&amp; arr[j] &gt;= standard){
                j--;
            }
            arr[i] = arr[j];
            while(i &lt; j &amp;&amp; arr[i] &lt;= standard){
                i++;
            }
            arr[j] = arr[i];
        }
        arr[i] = standard;
        quickSort3(arr,left,i-1);
        quickSort3(arr,i+1,right);
    }

    /**
     * 同上，对quickSort3进行优化(三数取中)，也是根据博客园：https://www.cnblogs.com/coderising/p/5708801.html
     * @param arr
     * @param left
     * @param right
     */
    public static void quickSort4(int[] arr, int left, int right){
        if(left &gt;= right){
            return;
        }
        int mid = (left+right)/2;
        if(arr[right] &lt; arr[left]){
            swap(arr,left,right);
        }
        if(arr[right] &lt; arr[mid]){
            swap(arr,mid,right);
        }
        if(arr[left] &lt; arr[mid]){
            swap(arr,left,mid);
        }
        int standard = arr[left];
        int i = left;
        int j = right;
        while(i &lt; j){
            while(i &lt; j &amp;&amp; arr[j] &gt;= standard){
                j--;
            }
            arr[i] = arr[j];
            while(i &lt; j &amp;&amp; arr[i] &lt;= standard){
                i++;
            }
            arr[j] = arr[i];
        }
        arr[i] = standard;
        quickSort3(arr,left,i-1);
        quickSort3(arr,i+1,right);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA面试题]]></title>
        <id>http://alang.two3.cn/post/java-mian-shi-ti</id>
        <link href="http://alang.two3.cn/post/java-mian-shi-ti">
        </link>
        <updated>2019-08-11T05:12:42.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>机会是留给有准备的人！</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>机会是留给有准备的人！</p>
</blockquote>
<!-- more -->
<ol>
<li>
<p>简单说下什么是跨平台？<br>
由于各种操作系统指令集不是完全一致的，所有在操作系统之上加个虚拟机可以来提供统一接口，屏蔽系统之间的差异。</p>
</li>
<li>
<p>java有几种基本数据类型</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">字节</th>
<th style="text-align:center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">8</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0.0f</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8</td>
<td style="text-align:center">0.0d</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">2</td>
<td style="text-align:center">'\u0000'</td>
</tr>
<tr>
<td style="text-align:center"><em><strong>boolean</strong></em></td>
<td style="text-align:center">4</td>
<td style="text-align:center">false</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>ArratList和LinkedList区别<br>
ArrayList是基于动态数组的数据结构，LinkedList是基于链表的数据结构。<br>
对于随机访问get和set,ArrayList优于LinkedList,因为LinkedList要移动指针。<br>
对于新增和删除add和remove，LinkedList优于ArrayList，因为ArrayList要移动数据。</p>
</li>
<li>
<p>ConncurrentModificationException异常出现的原因</p>
<pre><code class="language-java">  public class Test{
 	 public static void main(String[] args){
 		 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
 		 list.add(2);
 		 Iterator&lt;Integer&gt; ite = list.iterator();
 		 while(ite.hasNext()){
 			 Integer integer = ite.next();
 			 if(integer == 2){
 				 list.remove(integer);
 			 }
 		 }
 	 }
  }
</code></pre>
<p>执行上段代码是有问题的，会抛出<code>ConcurrentModification</code>异常。<br>
<strong>原因</strong>：调用list.remove()方法导致modCount和expectedModeCount的值不一致。</p>
<pre><code class="language-java">final void checkForComodication(){
    if(modCount != expectedModCount
   	 throw new ConcurrentModification();
}
</code></pre>
<p><strong>解决方法</strong>：在迭代器中如果要删除元素的话，需要调用Iterator类的remove方法。</p>
<pre><code class="language-java">public class Test{
    public static void main(String[] args){
   	 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
   	 list.add(2);
   	 Iterator&lt;Integer&gt; ite = list.iterator();
   	 while(ite.hasNext()){
   		 Integer integer = ite.next();
   		 if(integer == 2){
   			 ite.remove();//注意这个地方
   		 }
   	 }
    }
} 
</code></pre>
</li>
<li>
<p>String、StringBuffer和StringBuilder区别</p>
<ol>
<li>数据可变和不可变<br>
<code>String</code>底层使用一个不可变的字符数组private final char value[];所以它内容不可变；<br>
<code>StringBuffer</code>和<code>StringBuilder</code>都继承了<code>AbstractStringBuilder</code>底层使用的是可变字符数组：<code>char[] value</code>;</li>
<li>线程安全<br>
<code>StringBuilder</code>是线程不安全的，效率较高；而StringBuffer是线程安全的，效率较低。<br>
通过他们的<code>append()</code>方法来看，<code>StringBuffer</code>是有同步锁，而StringBuilder没有：</li>
</ol>
<pre><code class="language-java">@Override
public sychronized StringBuffer append(Object obj){
	toStringCache = null;
	super.append(String.valueOf(obj));
	return this;
}

@Override
public StringBuilder append(String str){
	super.append(str);
	return this;
}
</code></pre>
<ol start="3">
<li>相同点<br>
<code>StringBuilder</code>与<code>StringBuffer</code>有公共父类`AbstractStringBuilder'。</li>
</ol>
<p>最后，操作可变字符速度：<code>StringBuilder &gt; StringBuffer &gt; String</code>。</p>
</li>
<li>
<p>HashMap和HashTable、ConcurrentHashMap区别？<br>
相同点：<br>
1.HashMap和HashTable都实现Map接口<br>
2.都可以存储key-value数据<br>
不同点：<br>
1.HashMap可以将null作为key或value，HashTable不可以。<br>
2.HashMap是线程不安全，效率高，HashTable是线程安全，效率低。<br>
3.HashMap的迭代器(Iterator)是fail-fast迭代器,而HashTable的迭代器(enumerator)不是fail-fast。</p>
<blockquote>
<p>fail-fast:就是就快的时间能把错误抛出而不是让程序执行。</p>
</blockquote>
<p>如何保证线程安全又效率高？<br>
Java5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。<br>
我们能否让HashMap同步？<br>
HashMap可以通过下面的语句进行同步：<br>
<code>Map m = Collections.sychronizeMap(hashMap);</code></p>
</li>
<li>
<p>线程创建方式</p>
<ol>
<li>继承Thread类，作为线程对象存在(继承Thread对象)</li>
</ol>
<pre><code class="language-java">public class CreatThreadDemo1 extends Thread{
/**
 * 构造方法： 继承父类方法的Thread(String name)；方法
 * @param name
 */
public CreatThreadDemo1(String name){
    super(name);
}

@Override
public void run() {
    while (!interrupted()){
        System.out.println(getName()+&quot;线程执行了...&quot;);
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public static void main(String[] args) {
    CreatThreadDemo1 d1 = new CreatThreadDemo1(&quot;first&quot;);
    CreatThreadDemo1 d2 = new CreatThreadDemo1(&quot;second&quot;);

    d1.start();
    d2.start();

    d1.interrupt();  //中断第一个线程
}
}
</code></pre>
<p>常规方法，不多做介绍了，interrupted方法，是来判断该线程是否被中断。（终止线程不允许用stop方法，该方法不会施放占用的资源。所以我们在设计程序的时候，要按照中断线程的思维去设计，就像上面的代码一样）。</p>
<ol start="2">
<li>实现runnable接口作为线程任务存在</li>
</ol>
<pre><code class="language-java">public class CreatThreadDemo2 implements Runnable {
@Override
public void run() {
    while (true){
        System.out.println(&quot;线程执行了...&quot;);
    }
}

public static void main(String[] args) {
    //将线程任务传给线程对象
    Thread thread = new Thread(new CreatThreadDemo2());
    //启动线程
    thread.start();
}
}
</code></pre>
<p>Runnable 只是来修饰线程所执行的任务，它不是一个线程对象。想要启动Runnable对象，必须将它放到一个线程对象里。</p>
<ol start="3">
<li>匿名内部类创建线程对象</li>
</ol>
<pre><code class="language-java">public class CreatThreadDemo3 extends Thread{
public static void main(String[] args) {
    //创建无参线程对象
    new Thread(){
        @Override
        public void run() {
            System.out.println(&quot;线程执行了...&quot;);
        }
    }.start();
   //创建带线程任务的线程对象
    new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println(&quot;线程执行了...&quot;);
        }
    }).start();
    //创建带线程任务并且重写run方法的线程对象
    new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println(&quot;runnable run 线程执行了...&quot;);
        }
    }){
        @Override
        public void run() {
            System.out.println(&quot;override run 线程执行了...&quot;);
        }
    }.start();
}
}
</code></pre>
<p>创建带线程任务并且重写run方法的线程对象中，为什么只运行了Thread的run方法。我们看看Thread类的源码:<br>
<code>public class Thread implements Runnable{……}</code>;<br>
4.创建带返回值的线程</p>
<pre><code class="language-java">public class CreatThreadDemo4 implements Callable {
public static void main(String[] args) throws ExecutionException, InterruptedException {
    CreatThreadDemo4 demo4 = new CreatThreadDemo4();

    FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(demo4); //FutureTask最终实现的是runnable接口

    Thread thread = new Thread(task);

    thread.start();

    System.out.println(&quot;我可以在这里做点别的业务逻辑...因为FutureTask是提前完成任务&quot;);
    //拿出线程执行的返回值
    Integer result = task.get();
    System.out.println(&quot;线程中运算的结果为:&quot;+result);
}

//重写Callable接口的call方法
@Override
public Object call() throws Exception {
    int result = 1;
    System.out.println(&quot;业务逻辑计算中...&quot;);
    Thread.sleep(3000);
    return result;
}
}
</code></pre>
<p>Callable接口介绍：</p>
<pre><code class="language-java">public interface Callable&lt;V&gt; {
/**
 * Computes a result, or throws an exception if unable to do so.
 *
 * @return computed result
 * @throws Exception if unable to compute a result
 */
V call() throws Exception;
}
</code></pre>
<p>返回指定泛型的call方法。然后调用FutureTask对象的get方法得道call方法的返回值。</p>
<ol start="5">
<li>定时器Timer</li>
</ol>
<pre><code class="language-java">public class CreatThreadDemo5 {

public static void main(String[] args) {
    Timer timer = new Timer();

    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            System.out.println(&quot;定时器线程执行了...&quot;);
        }
    },0,1000);   //延迟0，周期1s

}
}
</code></pre>
<ol start="6">
<li>线程池创建线程</li>
</ol>
<pre><code class="language-java">public class CreatThreadDemo6 {
public static void main(String[] args) {
    //创建一个具有10个线程的线程池
    ExecutorService threadPool = Executors.newFixedThreadPool(10);
    long threadpoolUseTime = System.currentTimeMillis();
    for (int i = 0;i&lt;10;i++){
        threadPool.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+&quot;线程执行了...&quot;);
            }
        });
    }
    long threadpoolUseTime1 = System.currentTimeMillis();
    System.out.println(&quot;多线程用时&quot;+(threadpoolUseTime1-threadpoolUseTime));
    //销毁线程池
    threadPool.shutdown();
    threadpoolUseTime = System.currentTimeMillis();
}

}
</code></pre>
<p>7.利用java8新特性 stream 实现并发</p>
<pre><code class="language-java">public class CreatThreadDemo7 {
public static void main(String[] args) {
    List&lt;Integer&gt; values = Arrays.asList(10,20,30,40);
    //parallel 平行的，并行的
    int result = values.parallelStream().mapToInt(p -&gt; p*2).sum();
    System.out.println(result);
    //怎么证明它是并发处理呢
    values.parallelStream().forEach(p-&gt; System.out.println(p));
		}
	}
</code></pre>
</li>
</ol>
]]></content>
    </entry>
</feed>