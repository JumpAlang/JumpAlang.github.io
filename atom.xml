<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://git.alang.run</id>
    <title>Jump!Alang</title>
    <updated>2020-10-08T09:22:34.441Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://git.alang.run"/>
    <link rel="self" href="http://git.alang.run/atom.xml"/>
    <subtitle>永远年轻！永远热泪盈眶！</subtitle>
    <logo>http://git.alang.run/images/avatar.png</logo>
    <icon>http://git.alang.run/favicon.ico</icon>
    <rights>All rights reserved 2020, Jump!Alang</rights>
    <entry>
        <title type="html"><![CDATA[创建Springboot+Redis+NodeJs项目的Docker镜像]]></title>
        <id>http://git.alang.run/post/chuang-jian-springbootredisnodejs-xiang-mu-de-docker-jing-xiang/</id>
        <link href="http://git.alang.run/post/chuang-jian-springbootredisnodejs-xiang-mu-de-docker-jing-xiang/">
        </link>
        <updated>2020-10-08T01:18:50.000Z</updated>
        <summary type="html"><![CDATA[<p>考虑到应用<a href="http://music.alang.run">一起听歌吧</a> 开源地址：<a href="https://github.com/JumpAlang/Jusic-Serve-Houses">https://github.com/JumpAlang/Jusic-Serve-Houses</a><br>
后期可能要迁移服务器，也为了方便一起听歌吧的小伙伴在自己的服务器部署，制作一起听歌吧Docker镜像刻不容缓。</p>
]]></summary>
        <content type="html"><![CDATA[<p>考虑到应用<a href="http://music.alang.run">一起听歌吧</a> 开源地址：<a href="https://github.com/JumpAlang/Jusic-Serve-Houses">https://github.com/JumpAlang/Jusic-Serve-Houses</a><br>
后期可能要迁移服务器，也为了方便一起听歌吧的小伙伴在自己的服务器部署，制作一起听歌吧Docker镜像刻不容缓。</p>
<!-- more -->
<h1 id="认识docker">认识Docker</h1>
<blockquote>
<p>以下内容摘抄自阮一峰博客<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a>，建议之前没有使用过docker的小伙伴先看下，我也是看这篇入门的。</p>
</blockquote>
<p>2013年发布至今， Docker 一直广受瞩目，被认为可能会改变软件行业。<br>
软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p>
<p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p>
<p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：&quot;它在我的机器可以跑了&quot;（It works on my machine），言下之意就是，其他机器很可能跑不了。</p>
<p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来</p>
<h2 id="docker是什么">Docker是什么</h2>
<p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p>
<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>
<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<h2 id="docker的用途">Docker的用途</h2>
<p>Docker 的主要用途，目前有三大类。</p>
<p>（1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p>
<p>（2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p>
<p>（3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p>
<h1 id="镜像创建">镜像创建</h1>
<p>一起听歌吧项目主要可以拆分成三个镜像：</p>
<ol>
<li><strong>音乐接口api</strong>  一起听歌吧的音乐资源，包括网易、QQ、咪咕、铜钟（主要从酷我虾米找寻音乐），基础镜像：NodeJs</li>
<li><strong>Redis</strong> 一起听歌吧的数据服务，基础镜像：Redis</li>
<li><strong>一起听歌吧主程序</strong> 一起听歌吧的业务逻辑，依赖前面两个镜像，基础镜像：Java</li>
</ol>
<h2 id="音乐接口api制作">音乐接口api制作</h2>
<ol>
<li>准备<br>
把各个已经编译且可运行的音乐api代码（<em>包括node_modules</em>）拷贝到统一一个文件夹，方便进行shell操作。</li>
<li>编写Dockerfile<br>
之前看到一篇博客：<a href="https://zhuanlan.zhihu.com/p/130738206">nodejs 应用打包docker创建精简1G多镜像</a>，说NodeJs镜像很大,于是按照文章教程在本地制作了一个NodeJs基础镜像node_base</li>
</ol>
<pre><code class="language-shell">FROM node_base:latest #精简的NodeJs基础镜像，上文有说到

WORKDIR /app  #镜像的工作目录
COPY ./NeteaseCloudMusicApi ./NeteaseCloudMusicApi #把我本地的文件拷贝到镜像/app目录下
COPY ./QQMusicApi ./QQMusicApi
COPY ./MiguMusicApi ./MiguMusicApi
COPY ./tongzhongForJusic ./tongzhongForJusic

COPY ./entrypoint.sh .  #启动各个音乐api的脚本也要拷贝过去
RUN chmod +x ./entrypoint.sh #赋予脚本可执行权限

ENV QQ 1040927107  #qq音乐的环境变量：qq号，如果外部有配置-e QQ的环境变量，这里将被覆盖

ENTRYPOINT sh ./entrypoint.sh $QQ  #容器启动时执行的命令，这里是执行entrypoint.sh
EXPOSE 3000  #暴露端口给宿主机
EXPOSE 3300
EXPOSE 3400
EXPOSE 8081
</code></pre>
<ol start="3">
<li>编写entrypoint.sh 脚本</li>
</ol>
<pre><code class="language-Shell">#!/bin/bash
cd ./NeteaseCloudMusicApi #跳转容器相应目录
nohup node app.js &amp;  #执行启动音乐api命令，nohup指在后台运行
cd ../MiguMusicApi
nohup npm start &amp;
cd ../tongzhongForJusic
nohup npm run server &amp;
cd ../QQMusicApi
PORT=3300 QQ=$1 npm start  #$1,是指执行命令传递过来的第二个参数，第一个参数是entrypoint.sh，第二个参数是qq号
#记得这里不能加nohup让程序在后台运行，因为如果所有应用都在后台运行，docker会自动把这个容器给关闭了。
</code></pre>
<p><em>在windows下编写的脚本，回车可能导致在linux运行不了，建议在linux下编写脚本完拷贝过来</em></p>
<ol start="4">
<li>
<p>创建镜像<br>
<code>docker image build -t jusic_music_api:1.0 .</code></p>
</li>
<li>
<p>本地运行测试<br>
<code>docker run --name jusic_music_api -e QQ=1040927107 -p 3000:3000 -p 3300:3300 -p 3400:3400 -p 8081:8081 -d jusic_music_api:1.0</code><br>
运行后执行<code>docker ps</code>查看容器是否运行或者访问任一音乐api（如浏览器不能访问：<a href="localhost:3000">localhost:3000</a>，则说明没启动成功，可以使用docker命令查看日记：<code>docker logs jusic_music_api</code>，或者在entrypoint.sh添加一些辅助日记，如<code>echo pwd &gt; test.txt</code>）,<br>
进入容器内部执行命令：<code>docker exec -it jusic_music_api sh</code>。</p>
</li>
<li>
<p>发布镜像<br>
如果测试一切运行正常，那就可以把镜像发布至docker官方。<br>
一.  登录<br>
<code>docker login</code><br>
二.  为本地的 image 标注用户名和版本<br>
<code>docker image tag jusic_music_api:1.0 jumpalang/jusic_music_api:1.0</code><br>
三. 发布镜像<br>
<code>docker image push jumpalang/jusic_music_api:1.0</code><br>
四. 完善镜像详细信息<br>
访问官方镜像网站<a href="http://hub.docker.com">http://hub.docker.com</a>，填写镜像的描述信息及详细信息</p>
</li>
</ol>
<h2 id="一起听歌吧主程序镜像制作">一起听歌吧主程序镜像制作</h2>
<ol>
<li>准备<br>
一. 为了不额外的部署前端页面，把前端页面放到后端的<code>resources/static</code>目录下。并在security模块放开相应静态资源路径。<br>
二. 把<code>application.yml</code>的系统相关配置参数化，方便通过环境变量直接配置，如房间数<code>house_size: ${HouseSize:32}</code>,如果没设置环境变量默认就是32，如果运行容器时有设置<code>-e HouseSize=64</code>,则房间数变为64。</li>
<li>编写Dockerfile</li>
</ol>
<pre><code class="language-Shell">FROM java:8
EXPOSE 8888
WORKDIR /app
ADD target/jusic-serve.jar ./jusic-serve.jar

ENV APIUSER=admin APIPWD=123456 RedisHost=redis MusicApi=http://jusicMusicApi
ENV MusicExpireTime=1200000 ReTryCount=1 VoteRate=0.3 WyTopUrl=3778678
ENV ServerJUrl=https://sc.ftqq.com/SCU64668T909ada7955daadfb64d5e7652b93fb135dad06e659369.send
ENV IpHouse=3 HouseSize=32

# 这边不要以nohup方式运行，不然容器会被docker自动关闭
ENTRYPOINT java -jar -DAPIUSER=$APIUSER -DAPIPWD=$APIPWD -DRedisHost=&quot;$RedisHost&quot; -DMusicApi=&quot;$MusicApi&quot; -DMusicExpireTime=$MusicExpireTime -DReTryCount=$ReTryCount -DVoteRate=$VoteRate -DWyTopUrl=$WyTopUrl -DServerJUrl=&quot;$ServerJUrl&quot; -DIpHouse=$IpHouse -DHouseSize=$HouseSize ./jusic-serve.jar
</code></pre>
<p><strong>参数说明</strong></p>
<ul>
<li>接口认证用户名：APIUSER，默认admin</li>
<li>接口认证密码：APIPWD 默认123456</li>
<li>Redis Host:RedisHost 默认redis，如果不是docker启动的redis，在本地可以直接填写localhost</li>
<li>音乐api host:MusicApi 默认http://jusicMusicApi,与你link的音乐api别名要保持一致，如果不是docker启动的音乐api，在本地可以填写 http://localhost</li>
<li>音乐链接过期时间：MusicExpireTime 默认1200000毫秒</li>
<li>获取音乐失败重试次数：ReTryCount 默认1次</li>
<li>投票切歌率：VoteRate 默认0.3</li>
<li>网易热歌榜歌单id：WyTopUrl 默认3778678</li>
<li>个人Server酱接口：ServerJUrl 默认https://sc.ftqq.com/SCU64668T909ada7955daadfb64d5e7652b93fb135dad06e659369.send，必须修改，否则当有用户@管理员时，消息会发到我这里</li>
<li>每个ip限制创建房间数：IpHouse 默认3个</li>
<li>系统最多可创建房间数：HouseSize 默认32个</li>
</ul>
<ol start="3">
<li>
<p>创建镜像<br>
<code>docker image build -t jusic_serve_houses:1.0 .</code></p>
</li>
<li>
<p>本地运行测试<br>
运行前要先拉取及运行redis及音乐api镜像<em>jusic_music_api</em><br>
<code>docker run --name jusic_serve_houses -e APIPWD=123 -e MusicApi=&quot;http://musicApi&quot; -p 8888:8888 -d --link redis:redis --link jusic_music_api:musicApi jusic_serve_houses:1.0</code><br>
浏览器访问<a href="localhost:8888">localhost:8888</a>查看效果，如果没启动成功，可以使用docker命令查看日记：<code>docker logs jusic_serve_houses</code>。进入容器内部执行命令：<code>docker exec -it jusic_serve_houses /bin/bash</code></p>
</li>
<li>
<p>发布镜像<br>
如果测试一切运行正常，那就可以把镜像发布至docker官方。<br>
一.  登录<br>
<code>docker login</code><br>
二.  为本地的 image 标注用户名和版本<br>
<code>docker image tag jusic_serve_houses:1.0 jumpalang/jusic_serve_houses:1.0</code><br>
三. 发布镜像<br>
<code>docker image push jumpalang/jusic_serve_houses:1.0</code><br>
四. 完善镜像详细信息<br>
访问官方镜像网站<a href="http://hub.docker.com">http://hub.docker.com</a>，填写镜像的描述信息及详细信息</p>
</li>
</ol>
<h2 id="使用docker-compose一键启动项目">使用docker-compose一键启动项目</h2>
<p>上一步骤运行一起听歌吧应用还比较麻烦，要自己先启动音乐api及redis，使用docker-compose就可以很方便的运行起整个项目，如未使用过docker-compose建议先看看阮一峰博客的这篇文章：<a href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">Docker 微服务教程</a></p>
<ol>
<li>
<p>编写docker-compose.yml</p>
<pre><code class="language-Shell">version: &quot;3&quot;
services:
 service_redis:
     restart: always #异常关闭后会再自动重启
     #    ports:
     #      - 6379:6379   #可以不暴露给宿主机
     image: redis
     container_name: redis
     environment:
         - TZ=Asia/Shanghai
     command: redis-server
     volumes:
         - D:\docker\redis\data:/data  #redis数据挂载到本地，不然重启容器数据就丢失了
 service_jusicMusicApi:
     image: jumpalang/jusic_music_api:1.0
     environment:
         - QQ=1040927107 #qq号
     container_name: jusicMusicApi
     ports:
         #      - &quot;3000:3000&quot;
         - &quot;3300:3300&quot;  #qq音乐接口要暴露给宿主机，因为有可能要设置cookie
         #      - &quot;3400:3400&quot;
         #      - &quot;8081:8081&quot;
     restart: always
 service_jusicServeHouses:
     container_name: jusicServeHouses
     image: jumpalang/jusic_serve_houses:1.0
     environment:
         - MusicApi=http://jusicMusicApi  #必须与service_jusicMusicApi的 container_name一致
         - APIUSER=admin  #api认证接口用户名
         - APIPWD=123456  #api认证接口密码
         - ServerJUrl=https://sc.ftqq.com/SCU64668T909ada7955daadfb64d5e7652b93fb135dad06e659369.send #server酱消息接口，用户@管理员时会通知微信
     # 其他要设置的环境变量都可在此设置
     ports:
         - &quot;8888:8888&quot;
     depends_on:
         - service_redis
         - service_jusicMusicApi
     restart: always
</code></pre>
</li>
<li>
<p>本地运行测试<br>
<code>docker-compose up -d</code>, 启动相关容器，<em>-d</em>参数使得容器在后台运行。<br>
<code>docker-compose stop</code> 关闭相关容器<br>
<code>docker-compose rm</code> 删除相关容器</p>
</li>
</ol>
<h1 id="docker其他常用命令">docker其他常用命令</h1>
<ul>
<li>
<p>列出本机的所有 image 文件。<br>
<code>docker image ls</code></p>
</li>
<li>
<p>拉取镜像至本地<br>
<code>docker image pull library/hello-world</code><br>
library/hello-world是 image 文件在仓库里面的位置，其中library是 image 文件所在的组，hello-world是 image 文件的名字。<br>
由于 Docker 官方提供的 image 文件，都放在library组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p>
</li>
<li>
<p>删除 image 文件<br>
<code>docker image rm [imageName]</code></p>
</li>
<li>
<p>列出本机正在运行的容器<br>
<code>docker container ls</code></p>
</li>
<li>
<p>列出本机所有容器，包括终止运行的容器<br>
<code>docker container ls --all</code></p>
</li>
<li>
<p>启动容器<br>
<code>docker container start [containerID]</code><br>
<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用docker container start命令，它用来启动已经生成、已经停止运行的容器文件。</p>
</li>
<li>
<p>关闭容器<br>
<code>docker container stop [containerID]</code><br>
<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。<br>
这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p>
</li>
<li>
<p>删除容器<br>
<code>docker container rm [containerID]</code></p>
</li>
</ul>
<h1 id="总结">总结</h1>
<ol>
<li>制作镜像时，切记不能让所有应用都在后台运行，要保持一个在前台运行</li>
<li>docker还停留在表面使用，参数详细作用或者参数之间的区别还未了解，如links与depends_on区别</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开源的优秀后端管理系统]]></title>
        <id>http://git.alang.run/post/kai-yuan-de-you-xiu-hou-duan-guan-li-xi-tong/</id>
        <link href="http://git.alang.run/post/kai-yuan-de-you-xiu-hou-duan-guan-li-xi-tong/">
        </link>
        <updated>2020-09-27T02:08:54.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>寻觅时间：2020/9/27</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>寻觅时间：2020/9/27</strong></p>
<!-- more -->
<h1 id="寻觅1">寻觅1</h1>
<p>从公众号<code>Java技术驿站</code>看到一篇文章<a href="%22https://mp.weixin.qq.com/s/KfToO7xDzbHLva7rvwCOqQ%22">这 5 个能挣钱的 SpringBoot 项目，真TMD香！</a>，正好我也有想找个可以快速开发的通用后台系统模板。<br>
其中两个吸引了我的注意： <a href="%22https://gitee.com/lab1024/smart-admin%22">SmartAdmin</a> <code>start 1k fork 400</code> 和 <a href="%22https://gitee.com/aun/Timo%22">Timo</a>,<code>start 1.6k fork 673</code>。</p>
<h2 id="项目详情">项目详情</h2>
<h3 id="smartadmin">SmartAdmin</h3>
<ul>
<li>前端：Vue + Vue-Router + Vuex + ViewUI + vue-enum</li>
<li>后端：SpringBoot2 + Mybatis-plus + jwt + druid + mysql</li>
</ul>
<blockquote>
<p>在线预览 <a href="http://preview.smartadmin.1024lab.net">http://preview.smartadmin.1024lab.net</a><br>
<code>start 1k fork 400</code>    <code>前后端分离</code>  <code>前后端代码规范文档</code> <code>维护中</code> <code>始于2019-11-16</code> <code>5天前更新</code></p>
</blockquote>
<h3 id="timo">Timo</h3>
<ul>
<li>
<p>前端：Layui + Jquery + zTree + Font-awesome</p>
</li>
<li>
<p>后端：SpringBoot + Spring Data Jpa + Thymeleaf + Shiro + Jwt + EhCache</p>
<blockquote>
<p>在线预览 <a href="http://demo.linln.cn">http://demo.linln.cn</a><br>
<code>start 1.6k fork 673</code>  <code>前后端分离</code>  <code>移动端适配</code> <code>维护中</code> <code>始于2018-10-12</code> <code>3天前更新</code></p>
</blockquote>
<h1 id="寻觅2">寻觅2</h1>
</li>
</ul>
<p>因为之前都习惯于在github搜索开源项目，但从github clone项目很慢，发现上面提到的项目都有提供gitee的项目地址，于是转站gitee clone项目。<br>
出于好奇，我也在gitee上搜索了<code>后台管理</code>，然后筛选<em>java</em>项目，发现了另一个优秀的项目<a href="https://gitee.com/elunez/eladmin">eladmin</a> <code>start 3.3k fork 1.8k</code></p>
<h2 id="项目详情-2">项目详情</h2>
<h3 id="eladmin">eladmin</h3>
<ul>
<li>前端：Vue + ElementUI</li>
<li>后端:  Spring Boot 2.1.0 +Spring Boot Jpa+ JWT+Spring Security+Redis + Mysql
<blockquote>
<p>在线预览 <a href="https://el-admin.xin/">https://el-admin.xin/</a><br>
<code>start 3.3k fork 1.8k</code>  <code>前后端分离</code>  <code>移动端适配</code> <code>维护中</code> <code>始于2018-12-22</code> <code>6天前更新</code></p>
</blockquote>
</li>
</ul>
<h1 id="总结">总结</h1>
<p>从我自身出发，我倾向于使用mybatis操作数据。于是smartAdmin成为了选择，但是它移动端不适配。想想是不是也可以尝试下spring jpa，没错，那就从eladmin开始吧。而对于Timo很适合于自己赚外快接单使用，可以不前后端分离，方便部署……</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pm2的简单使用]]></title>
        <id>http://git.alang.run/post/pm2-de-jian-dan-shi-yong/</id>
        <link href="http://git.alang.run/post/pm2-de-jian-dan-shi-yong/">
        </link>
        <updated>2020-08-07T07:44:25.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>日常开发中需要启动一个node项目，需要用npm run …,，如果终端被关掉，程序也就自动停止，有时候几个项目一起跑起来，好几个终端开着，个人不太喜欢，有一神器可以解决：pm2。pm2 是一个带有负载均衡功能的Node应用的进程管理器.当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的。它非常适合IaaS结构，但不要把它用于PaaS方案。</p>
</blockquote>
<h1 id="启动应用并设置别名">启动应用并设置别名</h1>
<ol>
<li>没有app.js的启动方法(<em>有app.js但启动不了时也可以用这个</em>)<br>
<code>pm2 start npm -- name 别名 -- run start</code></li>
<li>有app.js<br>
<code>pm2 start app.js --name 别名</code></li>
</ol>
<h1 id="查看应用列表">查看应用列表</h1>
<p><code>pm2 list</code></p>
<h1 id="删除应用">删除应用</h1>
<p><code>pm2 delete 序号|别名</code></p>
<h1 id="重启应用">重启应用</h1>
<p><code>pm2 restart 序号|别名</code></p>
<h1 id="停止应用">停止应用</h1>
<p><code>pm2 stop 序号|别名</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[muse-ui+vue-cli编译兼容ie10/11]]></title>
        <id>http://git.alang.run/post/muse-uivue-cli-bian-yi-jian-rong-ie1011/</id>
        <link href="http://git.alang.run/post/muse-uivue-cli-bian-yi-jian-rong-ie1011/">
        </link>
        <updated>2020-06-06T09:00:41.000Z</updated>
        <summary type="html"><![CDATA[<p>muse-ui有用到es6语法，如箭头函数，因此无法在ie10/11使用，vue-cli有提供了解决方案，可以把项目的依赖包（如<code>muse-ui</code>）在打包时进行转换以兼容ie。</p>
]]></summary>
        <content type="html"><![CDATA[<p>muse-ui有用到es6语法，如箭头函数，因此无法在ie10/11使用，vue-cli有提供了解决方案，可以把项目的依赖包（如<code>muse-ui</code>）在打包时进行转换以兼容ie。</p>
<!-- more -->
<h1 id="背景">背景</h1>
<p>把一个muse-ui+vue的项目用HbuilderX打包成h5+app，在我的华为手机荣耀畅玩X7可以正常运行。但突然有个网友反应vivo手机安装app后页面一片空白，他说可能是他的手机系统比较早的原因导致。</p>
<h1 id="寻找原因">寻找原因</h1>
<p>于是拿出我手头的oppo手机测试也是一样空白（庆幸可以复原出相同问题）。于是用HbuilderX进行真机调试。发现一启动报错：<code>Uncaught SyntaxError:Unexpected token=&gt;</code>，定位到报错代码，发现是一个箭头函数报错。于是百度谷歌了一番，找到了问题大致原因：<strong>浏览器内核不支持es6语法</strong>，于是尝试着在电脑ie10打开页面发现也是报同样的错误。</p>
<h1 id="解决问题">解决问题</h1>
<p>综合了网上很多文章的意见及自己尝试，最终解决方案如下：</p>
<ol>
<li>修改.browserslistrc文件支持ie10<pre><code class="language-JSON"> &gt; 1%
 last 2 versions
 not ie &lt; 10
</code></pre>
</li>
<li>在main.js<strong>首行</strong>引入core-js，原因详见参考文章<pre><code class="language-js">import &quot;core-js&quot;; //首行
</code></pre>
</li>
<li>修改babel.config.js文件，新增useBuiltIns配置，原因详见参考文章<pre><code class="language-js"> module.exports = {
    presets: [
        ['@vue/cli-plugin-babel/preset', {useBuiltIns: 'entry'}]
    ],
    &quot;plugins&quot;: [&quot;transform-object-rest-spread&quot;] //不能解析es6语法关键解决

    }
</code></pre>
</li>
<li>修改vue.config.js文件，前面配置的可以让项目自身的代码兼容ie,但由于muse-ui是依赖包，还需要单独再列出让vue-cli编译兼容。<pre><code class="language-js">   module.exports = {
        publicPath: './',
        transpileDependencies: [&quot;muse-ui&quot;]       // 需要编译的依赖包名
    };
</code></pre>
</li>
</ol>
<h1 id="总结">总结</h1>
<ul>
<li>由vivo手机安装app后页面的空白问题，再延伸到ie的兼容性，这步很重要。ie兼容性在电脑就好调试多了。</li>
<li>自己前端知识的贫瘠，以后还是要多学习，广涉略。</li>
</ul>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://juejin.im/post/5eb77b0ae51d451aff30c910">记一次Vue-Cli项目兼容IE10的问题</a></li>
<li><a href="https://juejin.im/post/5e8acfd651882573ab44fa5b">通过vuecli3.0+兼容IE踩坑记录，学习解决问题的方式</a></li>
<li><a href="https://cli.vuejs.org/zh/guide/browser-compatibility.html">vue-cli官网浏览器兼容性</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IT生活经验]]></title>
        <id>http://git.alang.run/post/it-sheng-huo-jing-yan/</id>
        <link href="http://git.alang.run/post/it-sheng-huo-jing-yan/">
        </link>
        <updated>2020-05-18T04:31:29.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>要爬取一个网站的内容，可以看下这个网站是否开源，如果开源可以试着在本地运行，可能你要的数据可以直接借助它生成。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么大多数人穷其一生，终究一无所获？]]></title>
        <id>http://git.alang.run/post/wei-shi-me-da-duo-shu-ren-qiong-qi-yi-sheng-zhong-jiu-yi-wu-suo-huo/</id>
        <link href="http://git.alang.run/post/wei-shi-me-da-duo-shu-ren-qiong-qi-yi-sheng-zhong-jiu-yi-wu-suo-huo/">
        </link>
        <updated>2019-12-03T09:34:04.000Z</updated>
        <summary type="html"><![CDATA[<p>潜意识决定了你95%的人生。而潜意识你可以通过催眠、重复来改变。</p>
]]></summary>
        <content type="html"><![CDATA[<p>潜意识决定了你95%的人生。而潜意识你可以通过催眠、重复来改变。</p>
<!-- more -->
<div style="text-align:center; ">
	 <div>
		<video controls="controls" >
		<source src="http://qiniu.alang.run//video/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA%E7%A9%B7%E5%85%B6%E4%B8%80%E7%94%9F%EF%BC%8C%E7%BB%88%E7%A9%B6%E4%B8%80%E6%97%A0%E6%89%80%E8%8E%B7%EF%BC%9F%E7%9C%8B%E6%95%99%E6%8E%88%E7%B2%BE%E8%BE%9F%E7%9A%84%E5%88%86%E6%9E%90%EF%BC%81.mp4" type="video/mp4" />
		</video>
	</div>
	</div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Outside》张钰琪NASA演唱]]></title>
        <id>http://git.alang.run/post/outside-zhang-yu-qi-nasa-yan-chang/</id>
        <link href="http://git.alang.run/post/outside-zhang-yu-qi-nasa-yan-chang/">
        </link>
        <updated>2019-11-26T12:50:21.000Z</updated>
        <summary type="html"><![CDATA[<div style="text-align:center;">
	<div>
			<audio  controls="controls"  autoplay="autoplay">
			<source src="http://qiniu.alang.run//music/outside%E6%9C%89%E5%89%AA%E8%BE%91.m4a" type="audio/mpeg" />
	</audio>
	</div>
</div>
]]></summary>
        <content type="html"><![CDATA[<div style="text-align:center;">
	<div>
			<audio  controls="controls"  autoplay="autoplay">
			<source src="http://qiniu.alang.run//music/outside%E6%9C%89%E5%89%AA%E8%BE%91.m4a" type="audio/mpeg" />
	</audio>
	</div>
</div>
<!-- more -->
<ul>
<li>Ten thousand meters high it is light which is magical<br>
万米高空中飘着迷人的极光</li>
<li>run out of my hope using my last strength to lying on the snow<br>
我希望不再用尽力气躺入雪中</li>
<li>Finally gonna know a place where I could put my soul<br>
终将有一个地方能安放灵魂</li>
<li>Try to leave in a calm way with only my god knows<br>
我在沉默中离开 只有上天知道</li>
<li>Coming for the night<br>
去向黑暗</li>
<li>We flying so high<br>
我们在飞行</li>
<li>My heart could cross millions of miles<br>
我的心跨越一千英里</li>
<li>I’m going to the wild<br>
去向自由</li>
<li>I going through the light<br>
越过光圈</li>
<li>And hearing the calling from the other side<br>
听见世界另一边的呼唤</li>
<li>I touch the universe I touch your hand<br>
触摸宇宙 触碰指尖</li>
<li>Your eyes are like the pure sapphire<br>
你的眼睛像纯净蓝宝石</li>
<li>The river would run for another thousand so do we could be remained forever<br>
银河将再流淌下一个一千年就像我们永不改变</li>
</ul>
<div style="text-align:center;">
	 <div>
		<video controls="controls" >
		<source src="http://qiniu.alang.run//video/%E9%92%B0%E7%90%AA%E7%99%BB%E7%BE%8E%E5%9B%BDNASA%E9%A2%81%E5%A5%96%E7%A4%BC%E7%8C%AE%E5%94%B1%EF%BC%8C%E5%8E%9F%E5%88%9B%E3%80%8AOutside%E3%80%8B.mp4" type="video/mp4" />
		</video>
	</div>
	</div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[thingsboard gateway http扩展匹配多级路径]]></title>
        <id>http://git.alang.run/post/thingsboard-gateway-http-kuo-zhan-pi-pei-duo-ji-lu-jing/</id>
        <link href="http://git.alang.run/post/thingsboard-gateway-http-kuo-zhan-pi-pei-duo-ji-lu-jing/">
        </link>
        <updated>2019-11-13T02:47:43.000Z</updated>
        <summary type="html"><![CDATA[<p>调测http扩展时，发现转换器序列号中的url只能配置一级，如只支持<code>green</code>格式，不支持<code>green/1/2/3</code>之类多级。</p>
]]></summary>
        <content type="html"><![CDATA[<p>调测http扩展时，发现转换器序列号中的url只能配置一级，如只支持<code>green</code>格式，不支持<code>green/1/2/3</code>之类多级。</p>
<!-- more -->
<h1 id="问题分析">问题分析</h1>
<p>查看HttpController源码：</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/uplink/{converterId}&quot;, method = RequestMethod.POST)
    public void handleRequest(@PathVariable String converterId,
                                            @RequestBody String body) throws Exception {
</code></pre>
<p>发现是使用springmvc的@PathVariable来匹配路径，而@PathVariable只支持一级路径，如下是大佬的原话：</p>
<blockquote>
<p>它在做匹配时直接会把green/report切成green和report两段，每段去和pattern的每一段匹配。</p>
</blockquote>
<p>大佬给出的建议是：</p>
<ol>
<li>修改antmatcher源码</li>
<li>/**去匹配，然后手工去拿最后一段</li>
</ol>
<p>选择了第二种方法，比较方便。<br>
带着问题找答案，找到一篇文章：<br>
<a href="https://blog.csdn.net/jiangxuexuanshuang/article/details/51720362">https://blog.csdn.net/jiangxuexuanshuang/article/details/51720362</a></p>
<h1 id="源码修改">源码修改</h1>
<p>把路径匹配的<code>/uplink/{converterId}</code>改成用<code>/**</code>去匹配：<code>/uplink/**</code>,然后写方法去提取这个<code>**</code>里面的内容。</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/uplink/**&quot;, method = RequestMethod.POST)
    public void handleRequest(HttpServletRequest request,
                                            @RequestBody String body) throws Exception {
                        String converterId = extractPathFromPattern(request);
                        service.processRequest(converterId, null, body);              
    }

    private String extractPathFromPattern(final HttpServletRequest request) {
        String path = (String) request.getAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE);
        String bestMatchPattern = (String) request.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE);
        return new AntPathMatcher().extractPathWithinPattern(bestMatchPattern, path);
    }
</code></pre>
<h1 id="测试">测试</h1>
<p>至thingsboard的设备管理下配置完网关的http扩展后，使用postman测试新增的http转换器：<br>
<img src="http://git.alang.run/post-images/1573616229936.png" alt="" loading="lazy"></p>
<h1 id="总结">总结</h1>
<p>暂无</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[thingsboard网关扩展与tb同步的理解]]></title>
        <id>http://git.alang.run/post/thingsboard-wang-guan-kuo-zhan-yu-tb-tong-bu-de-li-jie/</id>
        <link href="http://git.alang.run/post/thingsboard-wang-guan-kuo-zhan-yu-tb-tong-bu-de-li-jie/">
        </link>
        <updated>2019-11-04T07:20:31.000Z</updated>
        <summary type="html"><![CDATA[<p>最近由于要经常操作网关扩展，如添加http扩展，新增mqtt扩展的映射。经常出现网关不同步问题。导致了经过网关的数据，设备有创建，但是没有相应遥测数据，之前有看过群里大佬写过thingsboard网关与tb配置同步的源码分析：</p>
<blockquote>
<p><a href="https://blog.csdn.net/Zzhou1990/article/details/102477059">https://blog.csdn.net/Zzhou1990/article/details/102477059</a> <em><strong>Thingsboard Gateway 根据云端配置初始化</strong></em></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<p>最近由于要经常操作网关扩展，如添加http扩展，新增mqtt扩展的映射。经常出现网关不同步问题。导致了经过网关的数据，设备有创建，但是没有相应遥测数据，之前有看过群里大佬写过thingsboard网关与tb配置同步的源码分析：</p>
<blockquote>
<p><a href="https://blog.csdn.net/Zzhou1990/article/details/102477059">https://blog.csdn.net/Zzhou1990/article/details/102477059</a> <em><strong>Thingsboard Gateway 根据云端配置初始化</strong></em></p>
</blockquote>
<!-- more -->
<h1 id="前记">前记</h1>
<p>以下纯属本人臆想推测，难免会有疏漏。欢迎看者多加指正，互相进步。</p>
<h1 id="理解大佬源码分析">理解大佬源码分析</h1>
<p>从大佬文章中，大致可以理解成:当网关配置与thingsboard互通后，并允许thingsboard远程更新，则网关中连接thingsboard mqtt broker的mqtt客户端有订阅了属性更新主题<code>v1/devices/me/attributes</code>，用于实时获取共享属性更新。每当在thingsboard平台上配置网关扩展，thingsboard就会自动将配置信息保存为共享属性<code>configuration</code>的值。此时网关中的mqtt客户端监听到共享属性更新，会根据共享属性值重新初始化网关扩展配置。而后再把相应扩展配置上传至网关客户端属性<code>appliedConfiguration</code>,见如下代码：</p>
<pre><code class="language-java">private void updateConfiguration(String configuration) {
        try {
            if (extensionsConfigListener != null) {
                extensionsConfigListener.accept(configuration);
            }
            onAppliedConfiguration(configuration);
        } catch (Exception e) {
            log.warn(&quot;Failed to update extension configurations [[]]&quot;, e.getMessage(), e);
        }

public void onAppliedConfiguration(String configuration) {
        byte[] msgData = toBytes(newNode().put(&quot;appliedConfiguration&quot;, configuration));
        persistMessage(DEVICE_ATTRIBUTES_TOPIC, msgIdSeq.incrementAndGet(), msgData, null, null,
                error -&gt;
                        log.warn(&quot;Could not publish applied configuration&quot;, error));
    }
</code></pre>
<h1 id="同步状态判断依据">同步状态判断依据</h1>
<p>查阅thingsboard ui模块下的如下文件：<br>
<code>D:\JAVA\iot\code\thingsboard\ui\src\app\extension\extension-table.directive.js</code><br>
确认同步方法：</p>
<pre><code class="language-js">function reloadExtensions() {
        vm.subscribed = false;
        vm.allExtensions.length = 0;
        vm.extensions.length = 0;
        vm.extensionsPromise = attributeService.getEntityAttributesValues(vm.entityType, vm.entityId, types.attributesScope.shared.value, [&quot;configuration&quot;]);
        vm.extensionsPromise.then(
            function success(data) {
                if (data.length) {
                    vm.allExtensions = angular.fromJson(data[0].value);
                } else {
                    vm.allExtensions = [];
                }

                vm.selectedExtensions = [];
                updateExtensions();
                vm.extensionsPromise = null;
            },
            function fail() {
                vm.extensions = [];
                vm.selectedExtensions = [];
                updateExtensions();
                vm.extensionsPromise = null;
            }
        );
    }

function updateExtensions() {
        vm.selectedExtensions = [];
        var result = $filter('orderBy')(vm.allExtensions, vm.query.order);
        // $log.info(result);
        if (vm.query.search != null) {
            result = $filter('filter')(result, function(extension) {
                if(!vm.query.search || (extension.id.indexOf(vm.query.search) != -1) || (extension.type.indexOf(vm.query.search) != -1)) {
                    return true;
                }
                return false;
            });
        }
        vm.extensionsCount = result.length;
        var startIndex = vm.query.limit * (vm.query.page - 1);
        vm.extensions = result.slice(startIndex, startIndex + vm.query.limit);

        vm.extensionsJSON = angular.toJson(vm.extensions);
        checkForSync();
    }

function subscribeForClientAttributes() {
        if (!vm.subscribed) {
            if (vm.entityId &amp;&amp; vm.entityType) {
                $scope.subscriber = {
                    subscriptionCommands: [{
                        entityType: vm.entityType,
                        entityId: vm.entityId,
                        scope: 'CLIENT_SCOPE'
                    }],
                    type: 'attribute',
                    onData: function (data) {
                        if (data.data) {
                            onSubscriptionData(data.data);
                        }
                        vm.subscribed = true;
                    }
                };
                telemetryWebsocketService.subscribe($scope.subscriber);
            }
        }
    }

function onSubscriptionData(data) {
         // $log.info(data);
        if ($.isEmptyObject(data)) {
            vm.appliedConfiguration = undefined;
        } else {
            if (data.appliedConfiguration &amp;&amp; data.appliedConfiguration[0] &amp;&amp; data.appliedConfiguration[0][1]) {
                vm.appliedConfiguration = data.appliedConfiguration[0][1];
            }
        }

        updateExtensions();
        $scope.$digest();
    }

function checkForSync() {
         // $log.info(&quot;app:&quot;+vm.appliedConfiguration);
         // $log.info(&quot;ext:&quot;+vm.extensionsJSON);
        if (vm.appliedConfiguration &amp;&amp; vm.extensionsJSON &amp;&amp; vm.appliedConfiguration === vm.extensionsJSON) {
            vm.syncStatus = $translate.instant('extension.sync.sync');
            vm.syncLastTime = formatDate();
            $scope.isSync = true;
        } else {
            vm.syncStatus = $translate.instant('extension.sync.not-sync');

            $scope.isSync = false;
        }
    }
</code></pre>
<p>可以看出同步状态是通过判断网关的客户端属性<code>appliedConfiguration</code>与加工过的共享属性<code>configuration</code>值是否一致。<br>
同时发现一个自认为的bug：共享属性<code>configuration</code>会被排序加工成<code>extensionsJSON</code>,排序是根据扩展id升序排序的,所以会导致客户端属性与加工后的共享属性不一致，导致提示不同步，但好像并不影响使用：<br>
<code>var result = $filter('orderBy')(vm.allExtensions, vm.query.order);</code></p>
<pre><code class="language-js">vm.query = {
        order: 'id',
        limit: 5,
        page: 1,
        search: null
    };
</code></pre>
<p>所以我自己建议是添加网关扩展时id累加命名，如1_green,2_red。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[thingsboard gateway http扩展 创建设备、上传属性及遥测数据]]></title>
        <id>http://git.alang.run/post/thingsboard-gateway-http-kuo-zhan-shang-chuan-shu-xing-ji-yao-ce-shu-ju/</id>
        <link href="http://git.alang.run/post/thingsboard-gateway-http-kuo-zhan-shang-chuan-shu-xing-ji-yao-ce-shu-ju/">
        </link>
        <updated>2019-11-01T08:02:53.000Z</updated>
        <summary type="html"><![CDATA[<p>thingsboard官网文档有介绍网关mqtt扩展的使用，http扩展的使用方法找了许久也未找到。于是就想从thinsboard pe版本中的http整合找下灵感。pe版本中的http整合其实也就是提供中间的一个整合器服务和转换器（可以转换json/text/binary(base64)），然后跟着这个线索去查看gateway的源码，发现有一个controller有配置uplink上传链，至于downlink还待研究。<em><strong>对于thingsboard还是小白，如文章理解有误，希望看者多多帮忙指正，互相一起进步</strong></em></p>
]]></summary>
        <content type="html"><![CDATA[<p>thingsboard官网文档有介绍网关mqtt扩展的使用，http扩展的使用方法找了许久也未找到。于是就想从thinsboard pe版本中的http整合找下灵感。pe版本中的http整合其实也就是提供中间的一个整合器服务和转换器（可以转换json/text/binary(base64)），然后跟着这个线索去查看gateway的源码，发现有一个controller有配置uplink上传链，至于downlink还待研究。<em><strong>对于thingsboard还是小白，如文章理解有误，希望看者多多帮忙指正，互相一起进步</strong></em></p>
<!-- more -->
<h1 id="gateway源码查看">gateway源码查看</h1>
<p>在<code>HttpController</code>有如下方法：</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/uplink/{converterId}&quot;, method = RequestMethod.POST)
    public void handleRequest(@PathVariable String converterId,
                              @RequestBody String body) throws Exception {
        service.processRequest(converterId, null, body);
    }
</code></pre>
<h1 id="gateway扩展配置">gateway扩展配置</h1>
<p>至thingsboard平台配置网关设备的扩展，新增http扩展。如下：<br>
<img src="http://git.alang.run/post-images/1572596736680.png" alt="" loading="lazy"><br>
<img src="http://git.alang.run/post-images/1572596746058.png" alt="" loading="lazy"><br>
<img src="http://git.alang.run/post-images/1572596750984.png" alt="" loading="lazy"><br>
<img src="http://git.alang.run/post-images/1572596757416.png" alt="" loading="lazy"></p>
<h1 id="postman调用http扩展url">postman调用http扩展url</h1>
<p>上一步骤我们配置了转换器序列号为green,网关默认开启端口号为9090，则http请求地址为：网关地址ip:9090/uplink/green。<br>
<img src="http://git.alang.run/post-images/1572599651241.png" alt="" loading="lazy"></p>
<h1 id="至tb平台上查看设备及数据">至tb平台上查看设备及数据</h1>
<figure data-type="image" tabindex="1"><img src="http://git.alang.run/post-images/1572599728628.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>