<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://alang.two3.cn</id>
    <title>Jump!Alang</title>
    <updated>2019-10-16T17:16:26.729Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://alang.two3.cn"/>
    <link rel="self" href="http://alang.two3.cn/atom.xml"/>
    <subtitle>永远年轻！永远热泪盈眶！</subtitle>
    <logo>http://alang.two3.cn/images/avatar.png</logo>
    <icon>http://alang.two3.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, Jump!Alang</rights>
    <entry>
        <title type="html"><![CDATA[ThingsBoard修改logo及标题]]></title>
        <id>http://alang.two3.cn/post/thingsboard-xiu-gai-logo-ji-biao-ti</id>
        <link href="http://alang.two3.cn/post/thingsboard-xiu-gai-logo-ji-biao-ti">
        </link>
        <updated>2019-10-16T16:35:26.000Z</updated>
        <summary type="html"><![CDATA[<p>本来以为很简单的事，但其中问题不断，写在此愿能帮助遇到同样问题的你。<br>
要实时查看logo替换效果，建议在热部署模式下运行，官方文档：<a href="https://thingsboard.io/docs/user-guide/contribution/how-to-contribute/#running-ui-container-in-hot-redeploy-mode">https://thingsboard.io/docs/user-guide/contribution/how-to-contribute/#running-ui-container-in-hot-redeploy-mode</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>本来以为很简单的事，但其中问题不断，写在此愿能帮助遇到同样问题的你。<br>
要实时查看logo替换效果，建议在热部署模式下运行，官方文档：<a href="https://thingsboard.io/docs/user-guide/contribution/how-to-contribute/#running-ui-container-in-hot-redeploy-mode">https://thingsboard.io/docs/user-guide/contribution/how-to-contribute/#running-ui-container-in-hot-redeploy-mode</a></p>
<!-- more -->
<h1 id="定制自己的logo">定制自己的logo</h1>
<p>我这边使用的是在线网页制作svg：<a href="https://c.runoob.com/more/svgeditor/">https://c.runoob.com/more/svgeditor/</a></p>
<ol>
<li>准备工作<br>
把thingsboard原logo(存在此路径下：<code>/UI/src/svg/log_tilte_white.svg</code>)导入在线制作svg网页</li>
<li>制作<br>
导入成功后按delete把导入的thingsboard logo背景删除（主要是为了保证图片尺寸跟原thingsboard大致一致）</li>
</ol>
<h1 id="编辑制作好的svg代码">编辑制作好的svg代码</h1>
<p>把thingsboard源logo的头部复制到你制作好的svg头部（个人理解主要是为了保证宽度高度的一致）</p>
<p>thingsboard源logo头部</p>
<pre><code class="language-html">&lt;svg id=&quot;svg2&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; height=&quot;320&quot; width=&quot;1543.4&quot; version=&quot;1.1&quot; xmlns:cc=&quot;http://creativecommons.org/ns#&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; viewBox=&quot;0 0 1543.4268 320.00026&quot;&gt;
</code></pre>
<h1 id="编译">编译</h1>
<p>把图片拷贝到thingsboard原位置，重新编译打包(要先把thingsboard根路径下的pom.xml中的license-maven-plugin插件注释了)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[thingsboard rpc大佬总结]]></title>
        <id>http://alang.two3.cn/post/thingsboard-rpc-da-lao-zong-jie</id>
        <link href="http://alang.two3.cn/post/thingsboard-rpc-da-lao-zong-jie">
        </link>
        <updated>2019-09-27T07:42:54.000Z</updated>
        <summary type="html"><![CDATA[<p>感谢大佬：@苏州-大侠，@杭州～三升水<br>
QQ群：China Thingsboard（726442610）</p>
]]></summary>
        <content type="html"><![CDATA[<p>感谢大佬：@苏州-大侠，@杭州～三升水<br>
QQ群：China Thingsboard（726442610）</p>
<!-- more -->
<h1 id="苏州-大侠">苏州-大侠</h1>
<p>1.正常 我们都是通过 mqtt，modbus，opc UA向TB抛数据<br>
2.如果想要通过TB下发指令或下发数据，就是通过tb的rpc<br>
3.tb有rpc的专属topic，对不同的协议(modbus ,mqtt,opc ua)有不同的格式<br>
4.tb下发rpc可以通过规则链，部件或调API<br>
5.如用gateway的modbus采集地址位的数据，如果想要修改地址位的数据，这时就用rpc下发数据，gateway接受到rpc的数据，就会写入地址中</p>
<h1 id="杭州~三升水">杭州～三升水</h1>
<p>1.首先我们理解RPC是什么意思，RPC和框架中的远程服务调用是一样的<br>
2.因为TB他不是单机的，就是有多个服务在一起部署的，多个机器是通过Akka模型进行通讯的<br>
3.他用grpc来进行服务的调用和消息在多个实例上传递<br>
4.这2个分别是用集群获取消息和发送消息，无论数据采集还有其他<br>
<img src="http://alang.two3.cn/post-images/1569571494278.jpg" alt=""><br>
<img src="http://alang.two3.cn/post-images/1569571500277.jpg" alt=""><br>
5.TB把单机版和集群的API做了个区分<br>
6.所以你会看到2套API,总结就是，你不是集群部署的话，rpc那套用处不大，上面采集的接口（<code>就是mqtt,coap,http的通过主题发送消息</code>）也能满足你的要求<br>
7.像这种，就是那种多个集群在一起通信的，交互消息的终端打印信息<br>
<img src="http://alang.two3.cn/post-images/1569571672429.jpg" alt=""><br>
8.网关的作用主要是对于单体没有联网能力的设备，从自组网或者局域网中，到一个有联网能力的设备上，统一上传数据</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[thingsboard rest api使用准备]]></title>
        <id>http://alang.two3.cn/post/thingsboard-rest-api-shi-yong-zhun-bei</id>
        <link href="http://alang.two3.cn/post/thingsboard-rest-api-shi-yong-zhun-bei">
        </link>
        <updated>2019-09-25T00:33:17.000Z</updated>
        <summary type="html"><![CDATA[<p>服务器端核心API</p>
]]></summary>
        <content type="html"><![CDATA[<p>服务器端核心API</p>
<!-- more -->
<p>访问地址格式：http://YOUR_HOST:PORT/swagger-ui.html<br>
如官网示例为：<a href="http://demo.thingsboard.io/swagger-ui.html">http://demo.thingsboard.io/swagger-ui.html</a></p>
<p>要使用api之前，要先取得调用api的token。</p>
<h1 id="获取token">获取token</h1>
<p>post请求地址：http://THINGSBOARD_URL/api/auth/login，如官网示例则为：http://demo.thingsboard.io/api/auth/login<br>
postman调用样例，这边以我本地为例：<br>
<img src="http://alang.two3.cn/post-images/1569372720394.png" alt=""></p>
<h1 id="调用api准备">调用api准备</h1>
<p>调用api可以直接使用swagger-ui.html也可以在postman。</p>
<ul>
<li>swagger-ui调用api准备<br>
在Swagger UI右上角的“Authorize”按钮填充api_key，api_key为&quot;Bearer &quot;+token,记得Bearer后面有个空格。<br>
<img src="http://alang.two3.cn/post-images/1569373125236.png" alt=""></li>
<li>postman调用api准备<br>
要在header加上X-Authorization<br>
<img src="http://alang.two3.cn/post-images/1569373400730.png" alt=""></li>
</ul>
<h1 id="参考">参考</h1>
<p><a href="https://thingsboard.io/docs/reference/rest-api/">https://thingsboard.io/docs/reference/rest-api/</a> REST API</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[thingsboard gateWay概述]]></title>
        <id>http://alang.two3.cn/post/thingsboard-gateway-gai-shu</id>
        <link href="http://alang.two3.cn/post/thingsboard-gateway-gai-shu">
        </link>
        <updated>2019-09-24T00:46:02.000Z</updated>
        <summary type="html"><![CDATA[<p>thingsboard网关可让您将与旧式和第三方系统连接的IoT设备与ThingsBoard集成在一起。<br>
网关是ThingsBoard中的一种特殊类型的设备，能够充当连接到不同系统的外部设备和ThingsBoard之间的桥梁。网关API提供了使用单个MQTT连接在多个设备和平台之间交换数据的功能。网关还充当ThingsBoard设备，并且可以利用现有的MQTT Device API来报告统计信息，接收配置更新等等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>thingsboard网关可让您将与旧式和第三方系统连接的IoT设备与ThingsBoard集成在一起。<br>
网关是ThingsBoard中的一种特殊类型的设备，能够充当连接到不同系统的外部设备和ThingsBoard之间的桥梁。网关API提供了使用单个MQTT连接在多个设备和平台之间交换数据的功能。网关还充当ThingsBoard设备，并且可以利用现有的MQTT Device API来报告统计信息，接收配置更新等等。</p>
<!-- more -->
<h1 id="架构">架构</h1>
<p>对平台来说网关是一个设备：只不过网关的消息体和其他设备不一样，网关监听的是消息代理发送的消息。针对MQTT来说，网关只不过选择性监听了topic，构建了一个映射“map”关系。<br>
<img src="http://alang.two3.cn/post-images/1569286524998.png" alt=""></p>
<h1 id="可以解决什么问题">可以解决什么问题</h1>
<p>现实中大部分都是通过网关操作设备的，不管是MQTT还是modbus或者opc。<br>
问题一：如果你有1万台设备如何连接： 若是你有一万个设备，不可能一个一个用token去连的。<br>
网关就解决了这个问题，简单 的说，通过网关，是管理一批设备，不通过网关，是管理一个设备。</p>
<h1 id="功能">功能</h1>
<ul>
<li>MQTT扩展，用于控制，配置和收集使用现有协议连接到外部MQTT代理的IoT设备的数据。</li>
<li>OPC-UA扩展，用于从连接到OPC-UA服务器的IoT设备收集数据。</li>
<li>Sigfox扩展，用于从连接到Sigfox后端的IoT设备收集数据。</li>
<li>Modbus扩展可从通过Modbus协议连接的IoT设备收集数据。</li>
<li>在网络和硬件故障的情况下，所收集数据的持久性可确保数据传输。</li>
<li>自动重新连接到ThingsBoard集群。</li>
<li>简单但功能强大的将传入数据和消息映射为统一格式。</li>
</ul>
<h1 id="内部机制">内部机制</h1>
<p>例如，下面列出的默认映射将强制网关订阅传感器主题，并将传入的JSON消息中的serialNumber用作设备名称。类似地，模型和温度 json对象字段将映射到相应的ThingsBoard设备属性和遥测字段。</p>
<pre><code class="language-json">{
  &quot;topicFilter&quot;: &quot;sensors&quot;,
  &quot;converter&quot;: {
    &quot;type&quot;: &quot;json&quot;,
    &quot;filterExpression&quot;: &quot;&quot;,
    &quot;deviceNameJsonExpression&quot;: &quot;${$.serialNumber}&quot;,
    &quot;attributes&quot;: [
      {
        &quot;type&quot;: &quot;string&quot;,
        &quot;key&quot;: &quot;model&quot;,
        &quot;value&quot;: &quot;${$.model}&quot;
      }
    ],
    &quot;timeseries&quot;: [
      {
        &quot;type&quot;: &quot;double&quot;,
        &quot;key&quot;: &quot;temperature&quot;,
        &quot;value&quot;: &quot;${$.temperature}&quot;
      }
    ]
  }
}
</code></pre>
<h1 id="参考">参考</h1>
<p><a href="https://thingsboard.io/docs/iot-gateway/what-is-iot-gateway/">https://thingsboard.io/docs/iot-gateway/what-is-iot-gateway/</a> <em>什么是ThingsBoard IoT网关？</em><br>
<a href="https://thingsboard.io/docs/iot-gateway/getting-started/">https://thingsboard.io/docs/iot-gateway/getting-started/</a> <em>ThingsBoard IoT网关入门</em><br>
<a href="https://thingsboard.io/docs/reference/gateway-mqtt-api/">https://thingsboard.io/docs/reference/gateway-mqtt-api/</a> <em>MQTT网关API参考</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[你离开了南京，从此没有人和我说话]]></title>
        <id>http://alang.two3.cn/post/ni-chi-kai-liao-nan-jing-cong-ci-mei-you-ren-he-wo-shuo-hua</id>
        <link href="http://alang.two3.cn/post/ni-chi-kai-liao-nan-jing-cong-ci-mei-you-ren-he-wo-shuo-hua">
        </link>
        <updated>2019-08-26T14:36:20.000Z</updated>
        <summary type="html"><![CDATA[<div style="text-align:center;">
	<div>
			<audio  controls="controls" autoplay="autoplay">
			<source src="http://jumpalang.two3.cn//music/%E4%BD%A0%E7%A6%BB%E5%BC%80%E4%BA%86%E5%8D%97%E4%BA%AC%20%E4%BB%8E%E6%AD%A4%E6%B2%A1%E6%9C%89%E4%BA%BA%E5%92%8C%E6%88%91%E8%AF%B4%E8%AF%9D.mp3" type="audio/mpeg" />
	</audio>
	</div>
	</div>]]></summary>
        <content type="html"><![CDATA[<div style="text-align:center;">
	<div>
			<audio  controls="controls" autoplay="autoplay">
			<source src="http://jumpalang.two3.cn//music/%E4%BD%A0%E7%A6%BB%E5%BC%80%E4%BA%86%E5%8D%97%E4%BA%AC%20%E4%BB%8E%E6%AD%A4%E6%B2%A1%E6%9C%89%E4%BA%BA%E5%92%8C%E6%88%91%E8%AF%B4%E8%AF%9D.mp3" type="audio/mpeg" />
	</audio>
	</div>
	</div>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[冒泡、选择、插入、快速排序JAVA算法]]></title>
        <id>http://alang.two3.cn/post/mou-pao-xuan-ze-cha-ru-kuai-su-pai-xu-java-suan-fa</id>
        <link href="http://alang.two3.cn/post/mou-pao-xuan-ze-cha-ru-kuai-su-pai-xu-java-suan-fa">
        </link>
        <updated>2019-08-11T10:01:44.000Z</updated>
        <summary type="html"><![CDATA[<p>熟能生巧！</p>
]]></summary>
        <content type="html"><![CDATA[<p>熟能生巧！</p>
<!-- more -->
<h1 id="冒泡-选择-插入">冒泡、选择、插入</h1>
<pre><code class="language-java">public class OrdinarySortRepeat {
    public static void main(String[] args) {
        int[] arr = getRandomInts(10);
        int[] arr2 = Arrays.copyOf(arr,10);
        int[] arr3 = Arrays.copyOf(arr,10);
        int[] arr4 = Arrays.copyOf(arr,10);
        System.out.println(&quot;origin:&quot;+Arrays.toString(arr));
        bubbleSort(arr);
        System.out.println(&quot;bubbleSort:&quot;+Arrays.toString(arr));
        selectSort(arr2);
        System.out.println(&quot;selectSort:&quot;+Arrays.toString(arr2));
        insertSort(arr3);
        System.out.println(&quot;insertSort:&quot;+Arrays.toString(arr3));
        insertSort2(arr4);
        System.out.println(&quot;insertSort2:&quot;+Arrays.toString(arr4));
    }
    public static int[] getRandomInts(int length){
        int[] numbers = new int[length];
        Random random = new Random();
        for (int i = 0; i &lt; length; i++) {
            numbers[i] = random.nextInt(9999);
        }
        return numbers;
    }

    public static void swap(int[] arr, int a, int b){
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }

    public static void bubbleSort(int[] arr){
        for(int i = 0; i &lt; arr.length-1; i++){
            boolean isNoSorted = true;
            for(int j = 0; j &lt; arr.length-i-1; j++){
                if(arr[j] &gt; arr[j+1]){
                    swap(arr,j,j+1);
                    isNoSorted = false;
                }
            }
            if(isNoSorted){
                return;
            }
        }
    }

    public static void selectSort(int[] arr){
        for(int i = 0; i &lt; arr.length-1; i++){
            for(int j = i+1; j &lt; arr.length;j++){
                if(arr[i] &gt; arr[j]){
                    swap(arr,i,j);
                }
            }
        }
    }

    public static void insertSort(int[] arr){
        for(int i = 1; i &lt; arr.length; i++){
            int temp = arr[i];
            int j = i-1;
            while(j &gt;= 0 &amp;&amp; arr[j] &gt; temp){
                arr[j+1] = arr[j];
                j--;
            }
            arr[j+1] = temp;
        }
    }

    public static void insertSort2(int[] arr){
        for(int i = 1;i &lt; arr.length; i++){
            int temp = arr[i];
            int j;
            for(j = i-1; j &gt;= 0; j--){
                if(arr[j] &gt; temp){
                    arr[j+1] = arr[j];
                }else{
                    break;
                }
            }
            arr[j+1] = temp;
        }
    }
}

</code></pre>
<h1 id="快速排序">快速排序</h1>
<pre><code class="language-java">public class QuickSortRepeat {
    public static void main(String[] args) {
        int[] arr = getRandomInts(10);
        int[] arr2 = Arrays.copyOf(arr,10);
        int[] arr3 = Arrays.copyOf(arr,10);
        int[] arr4 = Arrays.copyOf(arr,10);
        System.out.println(&quot;origin:&quot;+Arrays.toString(arr));
        quickSort(arr,0,arr.length-1);
        System.out.println(&quot;quickSort:&quot;+Arrays.toString(arr));
        quickSort2(arr2,0,arr.length-1);
        System.out.println(&quot;quickSort2:&quot;+ Arrays.toString(arr2));
        quickSort3(arr3,0,arr.length-1);
        System.out.println(&quot;quickSort3:&quot;+Arrays.toString(arr3));
        quickSort4(arr4,0,arr.length-1);
        System.out.println(&quot;quickSort4:&quot;+Arrays.toString(arr4));
    }
    public static int[] getRandomInts(int length){
        int[] numbers = new int[length];
        Random random = new Random();
        for (int i = 0; i &lt; length; i++) {
            numbers[i] = random.nextInt(9999);
        }
        return numbers;
    }

    public static void swap(int[] arr, int a, int b){
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }

    /**
     * 根据阮一峰博客：http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html
     * @param arr
     * @param left
     * @param right
     */
    public static void quickSort(int[] arr, int left, int right){
        if(left &gt;= right){
            return;
        }
        int standard = arr[left];
        int index = left;
        for(int i = left+1; i &lt;= right; i++){
            if(arr[i] &lt; standard){
                arr[index] = arr[i];
                for(int j = i-1; j &gt; index;j--){
                    arr[j+1] = arr[j];
                }
                arr[++index] = standard;
            }
        }
        quickSort(arr,left,index-1);
        quickSort(arr,index+1,right);
    }

    /**
     * 根据马桶上看算法：http://developer.51cto.com/art/201403/430986.htm
     * @param arr
     * @param left
     * @param right
     */
    public static void quickSort2(int[] arr,int left, int right){
        if(left &gt;= right){
            return;
        }
        int standard = arr[left];
        int i = left;
        int j = right;
        while(i &lt; j){
            while(i &lt; j &amp;&amp; arr[j] &gt;= standard){
                j--;
            }
            while(i &lt; j &amp;&amp; arr[i] &lt;= standard){
                i++;
            }
            if(i &lt; j){
                swap(arr,i,j);
            }else{
                break;
            }
        }
        if(i != left){
            arr[left] = arr[i];
            arr[i] = standard;
        }

        quickSort2(arr,left,i-1);
        quickSort2(arr,i+1,right);
    }

    /**
     * 根据博客园：https://www.cnblogs.com/coderising/p/5708801.html
     * @param arr
     * @param left
     * @param right
     */
    public static void quickSort3(int[] arr, int left, int right){
        if(left &gt;= right){
            return;
        }
        int standard = arr[left];
        int i = left;
        int j = right;
        while(i &lt; j){
            while(i &lt; j &amp;&amp; arr[j] &gt;= standard){
                j--;
            }
            arr[i] = arr[j];
            while(i &lt; j &amp;&amp; arr[i] &lt;= standard){
                i++;
            }
            arr[j] = arr[i];
        }
        arr[i] = standard;
        quickSort3(arr,left,i-1);
        quickSort3(arr,i+1,right);
    }

    /**
     * 同上，对quickSort3进行优化(三数取中)，也是根据博客园：https://www.cnblogs.com/coderising/p/5708801.html
     * @param arr
     * @param left
     * @param right
     */
    public static void quickSort4(int[] arr, int left, int right){
        if(left &gt;= right){
            return;
        }
        int mid = (left+right)/2;
        if(arr[right] &lt; arr[left]){
            swap(arr,left,right);
        }
        if(arr[right] &lt; arr[mid]){
            swap(arr,mid,right);
        }
        if(arr[left] &lt; arr[mid]){
            swap(arr,left,mid);
        }
        int standard = arr[left];
        int i = left;
        int j = right;
        while(i &lt; j){
            while(i &lt; j &amp;&amp; arr[j] &gt;= standard){
                j--;
            }
            arr[i] = arr[j];
            while(i &lt; j &amp;&amp; arr[i] &lt;= standard){
                i++;
            }
            arr[j] = arr[i];
        }
        arr[i] = standard;
        quickSort3(arr,left,i-1);
        quickSort3(arr,i+1,right);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA面试题]]></title>
        <id>http://alang.two3.cn/post/java-mian-shi-ti</id>
        <link href="http://alang.two3.cn/post/java-mian-shi-ti">
        </link>
        <updated>2019-08-11T05:12:42.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>机会是留给有准备的人！</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>机会是留给有准备的人！</p>
</blockquote>
<!-- more -->
<ol>
<li>
<p>简单说下什么是跨平台？<br>
由于各种操作系统指令集不是完全一致的，所有在操作系统之上加个虚拟机可以来提供统一接口，屏蔽系统之间的差异。</p>
</li>
<li>
<p>java有几种基本数据类型</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">字节</th>
<th style="text-align:center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">8</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0.0f</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8</td>
<td style="text-align:center">0.0d</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">2</td>
<td style="text-align:center">'\u0000'</td>
</tr>
<tr>
<td style="text-align:center"><em><strong>boolean</strong></em></td>
<td style="text-align:center">4</td>
<td style="text-align:center">false</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>ArratList和LinkedList区别<br>
ArrayList是基于动态数组的数据结构，LinkedList是基于链表的数据结构。<br>
对于随机访问get和set,ArrayList优于LinkedList,因为LinkedList要移动指针。<br>
对于新增和删除add和remove，LinkedList优于ArrayList，因为ArrayList要移动数据。</p>
</li>
<li>
<p>ConncurrentModificationException异常出现的原因</p>
<pre><code class="language-java">  public class Test{
 	 public static void main(String[] args){
 		 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
 		 list.add(2);
 		 Iterator&lt;Integer&gt; ite = list.iterator();
 		 while(ite.hasNext()){
 			 Integer integer = ite.next();
 			 if(integer == 2){
 				 list.remove(integer);
 			 }
 		 }
 	 }
  }
</code></pre>
<p>执行上段代码是有问题的，会抛出<code>ConcurrentModification</code>异常。<br>
<strong>原因</strong>：调用list.remove()方法导致modCount和expectedModeCount的值不一致。</p>
<pre><code class="language-java">final void checkForComodication(){
    if(modCount != expectedModCount
   	 throw new ConcurrentModification();
}
</code></pre>
<p><strong>解决方法</strong>：在迭代器中如果要删除元素的话，需要调用Iterator类的remove方法。</p>
<pre><code class="language-java">public class Test{
    public static void main(String[] args){
   	 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
   	 list.add(2);
   	 Iterator&lt;Integer&gt; ite = list.iterator();
   	 while(ite.hasNext()){
   		 Integer integer = ite.next();
   		 if(integer == 2){
   			 ite.remove();//注意这个地方
   		 }
   	 }
    }
} 
</code></pre>
</li>
<li>
<p>String、StringBuffer和StringBuilder区别</p>
<ol>
<li>数据可变和不可变<br>
<code>String</code>底层使用一个不可变的字符数组private final char value[];所以它内容不可变；<br>
<code>StringBuffer</code>和<code>StringBuilder</code>都继承了<code>AbstractStringBuilder</code>底层使用的是可变字符数组：<code>char[] value</code>;</li>
<li>线程安全<br>
<code>StringBuilder</code>是线程不安全的，效率较高；而StringBuffer是线程安全的，效率较低。<br>
通过他们的<code>append()</code>方法来看，<code>StringBuffer</code>是有同步锁，而StringBuilder没有：</li>
</ol>
<pre><code class="language-java">@Override
public sychronized StringBuffer append(Object obj){
	toStringCache = null;
	super.append(String.valueOf(obj));
	return this;
}

@Override
public StringBuilder append(String str){
	super.append(str);
	return this;
}
</code></pre>
<ol start="3">
<li>相同点<br>
<code>StringBuilder</code>与<code>StringBuffer</code>有公共父类`AbstractStringBuilder'。</li>
</ol>
<p>最后，操作可变字符速度：<code>StringBuilder &gt; StringBuffer &gt; String</code>。</p>
</li>
<li>
<p>HashMap和HashTable、ConcurrentHashMap区别？<br>
相同点：<br>
1.HashMap和HashTable都实现Map接口<br>
2.都可以存储key-value数据<br>
不同点：<br>
1.HashMap可以将null作为key或value，HashTable不可以。<br>
2.HashMap是线程不安全，效率高，HashTable是线程安全，效率低。<br>
3.HashMap的迭代器(Iterator)是fail-fast迭代器,而HashTable的迭代器(enumerator)不是fail-fast。</p>
<blockquote>
<p>fail-fast:就是就快的时间能把错误抛出而不是让程序执行。</p>
</blockquote>
<p>如何保证线程安全又效率高？<br>
Java5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。<br>
我们能否让HashMap同步？<br>
HashMap可以通过下面的语句进行同步：<br>
<code>Map m = Collections.sychronizeMap(hashMap);</code></p>
</li>
<li>
<p>线程创建方式</p>
<ol>
<li>继承Thread类，作为线程对象存在(继承Thread对象)</li>
</ol>
<pre><code class="language-java">public class CreatThreadDemo1 extends Thread{
/**
 * 构造方法： 继承父类方法的Thread(String name)；方法
 * @param name
 */
public CreatThreadDemo1(String name){
    super(name);
}

@Override
public void run() {
    while (!interrupted()){
        System.out.println(getName()+&quot;线程执行了...&quot;);
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public static void main(String[] args) {
    CreatThreadDemo1 d1 = new CreatThreadDemo1(&quot;first&quot;);
    CreatThreadDemo1 d2 = new CreatThreadDemo1(&quot;second&quot;);

    d1.start();
    d2.start();

    d1.interrupt();  //中断第一个线程
}
}
</code></pre>
<p>常规方法，不多做介绍了，interrupted方法，是来判断该线程是否被中断。（终止线程不允许用stop方法，该方法不会施放占用的资源。所以我们在设计程序的时候，要按照中断线程的思维去设计，就像上面的代码一样）。</p>
<ol start="2">
<li>实现runnable接口作为线程任务存在</li>
</ol>
<pre><code class="language-java">public class CreatThreadDemo2 implements Runnable {
@Override
public void run() {
    while (true){
        System.out.println(&quot;线程执行了...&quot;);
    }
}

public static void main(String[] args) {
    //将线程任务传给线程对象
    Thread thread = new Thread(new CreatThreadDemo2());
    //启动线程
    thread.start();
}
}
</code></pre>
<p>Runnable 只是来修饰线程所执行的任务，它不是一个线程对象。想要启动Runnable对象，必须将它放到一个线程对象里。</p>
<ol start="3">
<li>匿名内部类创建线程对象</li>
</ol>
<pre><code class="language-java">public class CreatThreadDemo3 extends Thread{
public static void main(String[] args) {
    //创建无参线程对象
    new Thread(){
        @Override
        public void run() {
            System.out.println(&quot;线程执行了...&quot;);
        }
    }.start();
   //创建带线程任务的线程对象
    new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println(&quot;线程执行了...&quot;);
        }
    }).start();
    //创建带线程任务并且重写run方法的线程对象
    new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println(&quot;runnable run 线程执行了...&quot;);
        }
    }){
        @Override
        public void run() {
            System.out.println(&quot;override run 线程执行了...&quot;);
        }
    }.start();
}
}
</code></pre>
<p>创建带线程任务并且重写run方法的线程对象中，为什么只运行了Thread的run方法。我们看看Thread类的源码:<br>
<code>public class Thread implements Runnable{……}</code>;<br>
4.创建带返回值的线程</p>
<pre><code class="language-java">public class CreatThreadDemo4 implements Callable {
public static void main(String[] args) throws ExecutionException, InterruptedException {
    CreatThreadDemo4 demo4 = new CreatThreadDemo4();

    FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(demo4); //FutureTask最终实现的是runnable接口

    Thread thread = new Thread(task);

    thread.start();

    System.out.println(&quot;我可以在这里做点别的业务逻辑...因为FutureTask是提前完成任务&quot;);
    //拿出线程执行的返回值
    Integer result = task.get();
    System.out.println(&quot;线程中运算的结果为:&quot;+result);
}

//重写Callable接口的call方法
@Override
public Object call() throws Exception {
    int result = 1;
    System.out.println(&quot;业务逻辑计算中...&quot;);
    Thread.sleep(3000);
    return result;
}
}
</code></pre>
<p>Callable接口介绍：</p>
<pre><code class="language-java">public interface Callable&lt;V&gt; {
/**
 * Computes a result, or throws an exception if unable to do so.
 *
 * @return computed result
 * @throws Exception if unable to compute a result
 */
V call() throws Exception;
}
</code></pre>
<p>返回指定泛型的call方法。然后调用FutureTask对象的get方法得道call方法的返回值。</p>
<ol start="5">
<li>定时器Timer</li>
</ol>
<pre><code class="language-java">public class CreatThreadDemo5 {

public static void main(String[] args) {
    Timer timer = new Timer();

    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            System.out.println(&quot;定时器线程执行了...&quot;);
        }
    },0,1000);   //延迟0，周期1s

}
}
</code></pre>
<ol start="6">
<li>线程池创建线程</li>
</ol>
<pre><code class="language-java">public class CreatThreadDemo6 {
public static void main(String[] args) {
    //创建一个具有10个线程的线程池
    ExecutorService threadPool = Executors.newFixedThreadPool(10);
    long threadpoolUseTime = System.currentTimeMillis();
    for (int i = 0;i&lt;10;i++){
        threadPool.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+&quot;线程执行了...&quot;);
            }
        });
    }
    long threadpoolUseTime1 = System.currentTimeMillis();
    System.out.println(&quot;多线程用时&quot;+(threadpoolUseTime1-threadpoolUseTime));
    //销毁线程池
    threadPool.shutdown();
    threadpoolUseTime = System.currentTimeMillis();
}

}
</code></pre>
<p>7.利用java8新特性 stream 实现并发</p>
<pre><code class="language-java">public class CreatThreadDemo7 {
public static void main(String[] args) {
    List&lt;Integer&gt; values = Arrays.asList(10,20,30,40);
    //parallel 平行的，并行的
    int result = values.parallelStream().mapToInt(p -&gt; p*2).sum();
    System.out.println(result);
    //怎么证明它是并发处理呢
    values.parallelStream().forEach(p-&gt; System.out.println(p));
		}
	}
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笑口常开，好彩自然来]]></title>
        <id>http://alang.two3.cn/post/xiao-kou-chang-kai-hao-cai-zi-ran-lai</id>
        <link href="http://alang.two3.cn/post/xiao-kou-chang-kai-hao-cai-zi-ran-lai">
        </link>
        <updated>2019-08-07T07:42:30.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>小时候父母吵架闹到要离婚的地步时，我挺身而出劝解道：“难道你们就不能打一顿孩子消消气？非要闹到离婚不可？弟弟还那么小，你们打他，他又不会记仇！”</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>小时候父母吵架闹到要离婚的地步时，我挺身而出劝解道：“难道你们就不能打一顿孩子消消气？非要闹到离婚不可？弟弟还那么小，你们打他，他又不会记仇！”</p>
</blockquote>
<!-- more -->
<div style="text-align:center;">
	<h1>洗不完的头</h1>
	 <div>
		<video controls="controls"  autoplay="autoplay"  width="66%">
		<source src="http://jumpalang.two3.cn/%E6%B4%97%E4%B8%8D%E5%AE%8C%E7%9A%84%E5%A4%B4.mp4" type="video/mp4" />
		</video>
	</div>
	</div>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[idea快捷键]]></title>
        <id>http://alang.two3.cn/post/idea-kuai-jie-jian</id>
        <link href="http://alang.two3.cn/post/idea-kuai-jie-jian">
        </link>
        <updated>2019-07-26T15:49:38.000Z</updated>
        <summary type="html"><![CDATA[<p>此份快捷键是从myeclipse移植过来的，from<code>尚硅谷·宋红康 设置版</code></p>
]]></summary>
        <content type="html"><![CDATA[<p>此份快捷键是从myeclipse移植过来的，from<code>尚硅谷·宋红康 设置版</code></p>
<!-- more -->
<h1 id="simple">simple</h1>
<p>alt+r(run) 执行<br>
alt+enter 万能解错/生成返回值变量</p>
<p>alt+left 退回到前一个编辑的页面<br>
alt+right 进入到下一个编辑的页面</p>
<p>ctrl+c 复制代码<br>
ctlr+z 撤销<br>
ctrl+y 反撤销<br>
ctrl+x 剪切<br>
ctrl+v 粘贴<br>
ctrl+s 保存<br>
ctlr+a 全选</p>
<p>ctrl+o(outline) 查看类的结构<br>
ctrl+d(delete line) 删除一行或选中行</p>
<p>ctrl+E 打开最近修改的文件</p>
<p>ctrl+f 查找/替换(当前)<br>
ctrl+h 查找(全局)<br>
shift+shift 查找文件</p>
<p>tab 选中数行，整体往后移动tab<br>
shift+tab 选中数行，整体往前移动tab</p>
<p>F2 查看文档说明<br>
F4 查看继承关系</p>
<h1 id="altshift">alt+shift</h1>
<p>alt+shift+r(rename) 修改变量名与方法名<br>
alt+shift+s 生成构造器/get/set/toString<br>
alt+shift+z 生成try-catch等</p>
<p>alt+shift+f 局部变量抽取为成员变量<br>
alt+shift+m 局部代码抽取为方法</p>
<p>alt+shift+c(collapse) 收起所有方法<br>
alt+shift+x(expand) 打开所有方法</p>
<h1 id="ctrlshift">ctrl+shift</h1>
<p>ctrl+/ 单行注释<br>
ctrl+shift+/ 多行注释</p>
<p>shift+enter 向下开始新的一行<br>
ctrl+shift+enter 向上开始新的一行</p>
<p>ctrl+shift+t 查看源码（ctrl+选中指定结构也可）<br>
ctrl+shift+f(format) 格式化代码</p>
<p>ctrl+w 关闭当前打开的代码栏<br>
ctrl+shift+w 关闭打开的所有代码栏</p>
<p>ctrl+shift+y 大小写互转<br>
ctrl+shift+x 打开代码所在硬盘文件夹<br>
ctrl+shift+u(UML) 查看类的继承结构图<br>
ctrl+shift+h(call hierarchy) 查找方法在哪里被调用<br>
ctrl+shift+q 快速搜索类中的错误<br>
ctrl+shift+v 选择要粘贴的内容</p>
<h1 id="ctrlalt">ctrl+alt</h1>
<p>alt+/ 提示补全<br>
ctrl+alt+/ 提示方法参数 类型</p>
<p>alt+up 向上移动行<br>
alt+down 向下移动行<br>
ctrl+alt+down 向下复制行</p>
<p>ctrl+alt+h(method hierarchy) 查看方法多层重写结构<br>
ctrl+alt+f(favorites) 添加到收藏</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[(转载)高考完了，怎样选专业才能月薪八万]]></title>
        <id>http://alang.two3.cn/post/zhuan-zai-gao-kao-wan-liao-zen-yang-xuan-zhuan-ye-cai-neng-yue-xin-ba-wan</id>
        <link href="http://alang.two3.cn/post/zhuan-zai-gao-kao-wan-liao-zen-yang-xuan-zhuan-ye-cai-neng-yue-xin-ba-wan">
        </link>
        <updated>2019-07-11T03:55:35.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>本文转载自微信公众号<strong>九边</strong>，作者：<code>二号头目</code></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>本文转载自微信公众号<strong>九边</strong>，作者：<code>二号头目</code></p>
</blockquote>
<!--more-->
<p>首先得说下，本文非广告，广告的文案那个“作者”的地方写的是“特邀发布”，而不是“二号头目”。而且有些同学总拿广告词里的一些内容怼我，说广告文里一些内容不科学，这个我是知道的，但是那个文案也不是我写的啊，人家也不让我改，你们知道博主搞号有多艰辛了吧。咱们接下来说正事。</p>
<p>又到了一年一次的大学选专业，很多小伙伴后台让博主赶紧写一个帖子，说说选专业的事，一小部分小伙伴是因为自己要上大学了，更多的是侄子要上大学，或者小姨子要上大学，作为一个四有青年不甘心坐在旁边说一些无关痛痒的话，比如“学计算机挺好，隔壁老王他儿子才三十岁就秃了”，再比如“金融听起来还不错，楼上大妈她闺女卖P2P赚翻了”等等。</p>
<p>以及很多小伙伴不知道在哪搞到一个梗，多次问倒报考哪个专业毕业后能月薪八万，博主倒是确实见过这么高的工资，一会儿文中会提到。不过现实中很少开那么高工资，税高的受不了，一般公司都有别的玩法，把工资均摊到其他选项里，帮忙避税。</p>
<p>今天博主把自己知道的关于选专业的事跟大家分享下，大家可以参考下，万一有用呢。当然了，你们肯定不会只看我一个人的嘛，就当我说的是一个侧面，而且文中有一些我对职业的思考，希望对大家能有帮助。</p>
<p>首先我们得强调几个基本常识：</p>
<p>1、除了部分专业性极强的专业，比如医生和律师，绝大部分人在毕业五年内就开始折腾跟自己专业无关的事，尤其是这年代，对未来的确定性越来越低，而且有些专业在人才市场上根本没有匹配的工作，比如我的一个小伙伴都毕业多年了，尽管继承了他爹的洗车店现在还不错，不过他依旧长期关注人才市场的招聘启事，查看有招哲学系毕业的没。每次看到没人招哲学毕业生，就感慨家里有钱真是好，可以去读一些没卵用的专业。</p>
<p>2、能去大城市就去大城市，原因一会儿讲。</p>
<p>3、除非那种比较特殊的情况，<strong>先选学校，再选专业</strong>，你毕业两年后，基本没人问你哪个专业的，因为很多专业你说了别人也不懂，但是你说你大学名字，别人永远都可以再第一时间给你的大学找个位置放进去，比如“牛逼，名校啊”，或者“嗯，还不错，应该不是985就是211”，再或者“没咋听说过，应该和驻马店职业技术学校差不多吧”。等到工作五年之后，后续几乎不会有人关心你专业了，<strong>你的标签是由你之前工作的厂子和你的毕业学校共同组成的</strong>。——<code>我的想法：如果可以上好学校就选好学校，不能上就选个好专业</code>。</p>
<p>4、大学其实教不了你多少东西，基本全靠毕业后自己学，这也是为啥博主一直在说保持学习能力。“学习能力”这事有两重意思，一是不惧怕学习新东西，二是知道学习曲线，能够顺利抗过学习新知识初期的挫折感。</p>
<p>接下来我们讲几个博主了解的比较多的，因为这些问题博主几乎天天接触，了解不多的其他问题可以在评论区提，我不知道别人应该也可以解答。</p>
<p>首先，咱们一定要说金融。</p>
<p>金融领域我了解一些，大家首先要抛弃“学金融就可以赚钱”这一荒谬理论，相比其他领域，金融领域更像是“明星圈”，我们说，世界上有两种职业，一种是呈现出明显“头部效应”，也就是这个行业里1%的人拿走了99%的钱，金融就是这么一个领域，此外还有直播行业，头部主播一晚上可以赚一辆法拉利，头部以下的主播只能是喝汤；另一种是金字塔形的，头部用户赚的是不错，但是不会拿走太多，比如码农领域，我们公司最顶尖的码农跟普通码农的收入也超不过三倍。</p>
<p>一方面好像是搞金融的人很多都爱历史，所以共同爱好让我认识一堆搞金融的；另一方面我哥当初就是仰慕金融领域的金领气质，名校物理专业毕业，数学牛逼的一塌糊涂，去金融领域，准备用数学搞个模型什么的，就跟华尔街那些精英似的玩交易，后来就去了国内知名的一个基金公司，然后变成了一个拉皮条的，嗯，生活就是这么惨无人道。</p>
<p>上两张图吧，方便大家理解：</p>
<p>你以为的金融从业者：</p>
<figure data-type="image" tabindex="1"><img src="http://alang.two3.cn/post-images/1562817683446.jpg" alt=""></figure>
<p>现实里绝大部分金融从业者：</p>
<figure data-type="image" tabindex="2"><img src="http://alang.two3.cn/post-images/1562817687397.jpg" alt=""></figure>
<p>当然了，我哥去拉皮条不代表他赚的不多，他的主要工作是忽悠一些有钱人去买他们公司的一些理财产品，他从中抽成，旱涝保收，合同里写的很清楚，盈亏由客户自负，他们拉皮条的要收固定的管理费。通过这么多年的折腾，他成功取得了一群有钱人的信任，嗯，每年都会投，他每年就算不去线下拉皮条，收入也比那些互联网大厂的产品经理版本经理赚的多。</p>
<p>我问过他金融行业的事，他表示绝大部分都是拉皮条的，因为这个领域最难的事情不是怎么交易怎么赚钱，那玩意比较玄学，绝大部分交易员的交易盈利情况都赶不上大盘涨幅，剩下的交易员业绩还不如只猴，既然这样，往往基金公司会买一个组合，也就是一堆以往业绩不错的股票，放在那里慢慢涨，跟着大盘自由摇摆，基金公司最重要的任务就是去拉钱，有了钱，啥都好说，实在不行可以去做配资放高利贷嘛。所以正如微博上某金融大V说的，那种金融领域的妹子们绝大部分长得跟高端会所小姐姐似的，我也是后来才明白了他在暗示啥，虾仁诛心啊，大家不要学习他。</p>
<p>而且大部分银行或者金融公司招聘，招过去之后经常是在前台什么的，痛苦至极，每年都有一堆人找我说这事，当然了，博主作为社区的“知心姐夫”，也只能是听听，给不出什么合理建议。</p>
<p>而且这个行业是严重过剩的，我最近五年每年都会去一线招聘，因为现在国内的大厂，比如腾讯阿里巴巴华为什么的，都开始让项目Leader或者项目负责人自己去招聘，HR只负责把关，看看应聘的人有没有精神病或者会不会高压跳楼什么的，所以博主这样的技术相关领域的就得去招聘，招聘过程中发现一个问题，就是“海龟”太特么多了。软件行业海龟都多，金融行业那简直是乌央乌央。</p>
<p>可能是拜前些年对海龟的无底线崇拜，大批在国内都考不上大学的孩子被送到了海外去深造，这些人严重拉低了海归含金量，学成归国要建设祖国的时候，发现有些过量了。而且早期的企业家大部分都是农民企业家，看不懂留学生的学历含金量。</p>
<p>最近几年HR基本都是专业化了，小公司我不知道，你去大厂的HR部门看看，到处都是一堆留学归来的Linda和Abby，事实上留学生回国干HR已经是行业惯例了。</p>
<p>这些人最了解留学生，而且娓娓道来，有次吃饭，一个叫Jade的小姐姐跟我们普及了哪些大学是可以直接花钱上，哪些大学每年不咋招人，只收有钱人，哪些大学普通人无论如何也上不起等等，把我们几个土鳖听的一愣一愣，毕竟我们这些土鳖十万以内就可以把大学读完，有人甚至跟刘某东一样，没带钱就去上大学，人家留学生要花几百万，你们感受下。</p>
<p>一句话总结，英联邦的毕业生整体优势非常低，北美的相对较高。英联邦包括英国，澳大利亚，新西兰等等，大家去的时候仔细考虑下。这个趋势现在已经很明显，再过五六年，会更加明显。</p>
<p>为啥扯留学生那里去了呢？因为这些年去海外留学的10个里有7个学的是金融，而金融行业整体需求量并不高，而且跟周期有关，你们感受下。</p>
<p>金融说到这里，如果你家里条件好，并且对这个职业心里有数，再去报考，如果家境一般，以为学了金融就可以赚钱，我劝你啊，尽快放弃幻想轻装上阵，有助于身心健康。</p>
<p>说说为啥我经常说年轻人争取去大城市呢，结合这两天的新闻大家也都感觉到了，那些小地方，盘根错节，很有可能校长和公安局长都是一家子，相互提携，相互包庇，不管做啥事都得找人。</p>
<p>当然了，博主这样的成年人不会无聊到感慨社会怎么这么黑暗，我是说，小地方本质还是前现代社会，人情社会，不像大城市，陌生人社会，相互之间遵守简单规则，反而相处容易的多。不过也有个问题，如果在大城市将来混不下去，回到小地方，会过得略痛苦。</p>
<p>之前总有神经病感慨大城市里邻居之间比较冷漠，拜托，这样才是正常社会好不好，村里那种互相都认识，天天互相打探流言蜚语，每走几步就得跟人打招呼才特么烦人。</p>
<p>这时候肯定有小伙伴要问了，大城市房价高怎么办？</p>
<p>其实吧，不要太在意，大城市房价高主要是有人抬，繁荣赋予了一堆砖头以价值，偏远山区，索马里，委内瑞拉的房价并不高，你也不会去买，所以房价并不是实体的，它是繁荣本身。</p>
<p>你如果竞争力能跟得上大城市，自然能买得起，这个不是鸡汤，懂的人自然懂。而且收入曲线不是线性的，干着干着会有一个跳跃，如果没有，也保持平常心吧，咱们绝大部分人都是普通人，试试不行就算了。</p>
<p>美国人经常说“give a shoot”，也就是“打了一枪”，或者“尝试过”，一枪没开是遗憾，开了没打中就拉倒了，纠结也没用。我们尽量避免自己成了那种一辈子没做过艰难决定，没冒过险的人，就可以了。</p>
<p>而且我们总说，受过教育的成年人思考问题，少用“平均”这个说法，多用“二八定律”，比如中国人平均收入xxx，脑子不好的第一反应是还不如非洲，接受过教育的人第一反应是卧槽，前三亿人接近欧美了啊。</p>
<p>如果三亿没有接近欧美，那三亿再来一次“二八定律”，这六千万妥妥达到欧美发达国家标准了，正好欧美大国人口也就是这个级别，六七千万人，正好是一线城市人口，嗯，<strong>去一线就是出国</strong>。</p>
<p>咱们再说码农。</p>
<p>先说一句，码农里有将近一半不是计算机或者软件出身的，很多都是自动化机械什么的，也就是说如果你大学没读计算机，将来去做计算机相关的，也不别扭。</p>
<p>其次再说下工资。工资高主要是集中在互联网大厂中，这些厂子都财大气粗，所以工资高，此外还有一些刚融到资的，这类企业现在不明显了，去年的时候工资高到离谱，我招聘过一个货，转眼就被一家新公司以月薪八万抢去做区块链了，后来市场上突然没钱了，倒闭了一堆企业，刚才说的那小子也失业了，年初还在联系我有别的职位没，不知道现在咋样了，刚才给他发消息没鸟我，估计是觉得我要嘲笑他。</p>
<p>估计今后很多年都不会出现这种大井喷了。</p>
<p>但是高工资没了，不代表工资不高，码农这种智力密集而且有一定门槛的行业，注定在很长一段时间内不会太低。而且大家肯定有个纳闷地方，那么多人去学码农，会不会饱和?</p>
<p>饱和倒是也够呛，而且码农里也区分三六九等，饱和之后可能会拉低整体的工资，不过优秀的程序员依旧可以去好的厂子里继续卖。</p>
<p>而且每年写那么多代码，代码这玩意就跟中午吃剩下的剩饭一样，放久了就发霉，如果没人维护，产品很快就没法用了，这也是为啥我说将来代码会越来越多，需要的码农也越来越多。至于人工智能，听听得了，如果你现在就担心人工智能会取代你，所以干啥都虚，那你趁早别干了，不等人工智能取代你，你周围的人就把你给取代了。</p>
<p>此外很多小伙伴问我将来去做网络工程师，加入华某为，“黄沙百战穿金甲”，怎么样？</p>
<p>菊厂我恰好了解一些，就现在的情况，说实话不是特别好，这些年华某为通过“黑寡妇”策略，也就是通过极端压低通信设备和服务的价格，让友商混不下去，基本上干翻了所有对手，并且在技术和储备上遥遥领先，啥意思呢？你如果通信行业毕业，最好的选择就是去某为，但是某为现在路由器领域正在把研发内部转到手机那边去，内部路由器研发其实是过剩的。我说这个，大家参考下。</p>
<p>我们继续放几张图，大家感受下：</p>
<p>你以为的通信工程师：</p>
<figure data-type="image" tabindex="3"><img src="http://alang.two3.cn/post-images/1562818214463.jpg" alt=""></figure>
<p>真实的通信工程师：</p>
<figure data-type="image" tabindex="4"><img src="http://alang.two3.cn/post-images/1562818217930.jpg" alt=""></figure>
<p>而且这个第二张照片并没有瞎说，国家级通信网络复杂极了，每台设备都有上亿行代码，而且包括几十个厂商的，出现了不以人意志为转移的混沌性和随机性，经常出现不知道它为啥坏了，不知道为啥又自己好了，所以各国都经常想一些办法，来增加网络稳定性，很多国家都有给服务器开光的习惯。</p>
<figure data-type="image" tabindex="5"><img src="http://alang.two3.cn/post-images/1562818230406.jpg" alt=""></figure>
<p>再说下经济历史。</p>
<p>很多小伙伴说看博主写历史经济很有意思，将来去读这专业好不好？</p>
<p>经济先放下，历史非常不建议，喜欢的话跟博主一样研究就可以了，不然大概率一毕业就失业，而且根据我这些年的经验，没有自夸的意思，喜欢历史的人大概率<strong>显得</strong>挺博学，但是学历史的人都非常拧巴，一开口满嘴大词，不知道他们在说啥。</p>
<p>至于经济学，参考金融学。从我接触的人来看，经济金融知识真起作用的地方，主要是写财经类文章那伙人，因为那些复杂的金融用语只有在吹牛逼时候才有用，真实世界金融业主要是谈项目，谈分红，你扯那些术语，你的客户也就是那些有钱人或者企业家，他们又不懂经济学更不懂金融。想学金融赚钱你还不如去学会计。</p>
<p>再说下医生和律师，律师我就不多说了，因为我也不知道，身边律师不少，不过一直没弄清楚他们在忙啥，也不知道他们到底好不好混。</p>
<p>医生的话，我在微博做过调查，几乎所有学了医的小伙伴都反应自己忙的离谱还不赚钱，不建议其他小伙伴加入。不过我这些年在海外没少呆，明显感觉到一件事，就是我国是政府通过压迫医生行业来给老百姓发福利。</p>
<p>其实大家去过美国就有感觉，那边的医生都是金领，爽的不得了，我之前提到过，认识一个美国牙医，家里竟然有个小飞机，着实吓了一跳，后来才知道美国牙医能赚这么多的有很多。医生在美国是卖高端服务的，我有点相信在不久的将来，中国也会走上这条路。不过只是猜想，大家可以作为参考吧。</p>
<p>而且医生和律师跟码农有个明显不一样的地方，可能工资一样，但是前边那俩更有社会地位一些，地位这东西大家得慢慢体会。</p>
<p>说到这里大家肯定要说了，博主你能不能不拐弯抹角，能不能一句话概括下？</p>
<p>其实我的意思是，如果你家有钱，选啥都没问题，你甚至可以去学哲学嘛。</p>
<p>但是如果跟博主一样，出身比较普通，建议往技术层面靠，这样有这么几个好处：</p>
<p>首先，技术是相通的，而且心里也不惧，学了自动化分分钟转计算机，计算机混不下去了还可以去链家卖房，但是如果不是技术出身，想去做技术，心里就有点虚。这也是为啥他们学数学的人转行比较容易，尽管我经常说月薪两三万的码农只用得着初中数学，主要是他们心里不惧。</p>
<p>其次，学习技术可以有效治疗精神病，别笑，没瞎说，一般长期不干技术，就会产生一种怀才不遇的错觉，学了技术，知道随便一个小问题都可以让人折腾好几个通宵，人多多少少会谦恭一些，开始意识到社会比较复杂，而不是天天批评社会这不正常那又不对，一切都是体制问题，等等，毕竟大家基本都讨厌屁也不会还目空一切的精神病。博主自己就是通过技术治好了这个病。</p>
<p>最后，学了技术容易找工作，骑驴找马嘛，玩过《绝地求生》的小伙伴都知道，有时候着急找辆车，跑断腿都找不到，但是一旦先找辆车，哪怕是个破摩托，很快就可以找到别的车，有了车之后就能发现到处是车。把握住一个大机会之后，人生到处是机会。</p>
<p>文末，今天正好看到一个帖子，说2017年大学生毕业后的薪酬，呃，是不是没有大家想象的高？</p>
<figure data-type="image" tabindex="6"><img src="http://alang.two3.cn/post-images/1562818416597.jpg" alt=""></figure>
<p>而且可能有小伙伴纳闷，这是2017年的，现在是不是好很多，事实上2017年正好是烈火烹油那一年，去年就出现明显的降温，今年估计更明显。</p>
<p>当然了，放这个图的意思是大家不要被社会上各种猎奇的新闻给迷惑了双眼，现在远远没到“月薪一万活不下去”那种地步，埋头做好自己的事，抬头随时关注趋势，毕竟，坐在潮头，奋斗一年顶十年。</p>
]]></content>
    </entry>
</feed>